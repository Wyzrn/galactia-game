<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Galactica - Enhanced</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00ff00;
        }

        #gameCanvas {
            background: radial-gradient(ellipse at center, #001122 0%, #000000 100%);
            position: relative;
            width: 100vw;
            height: 100vh;
            cursor: none;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s infinite alternate;
        }

        @keyframes twinkle {
            0% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        .player {
            position: absolute;
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="14" y="0" width="4" height="8" fill="%2300ff00"/><rect x="10" y="8" width="12" height="4" fill="%2300ff00"/><rect x="12" y="12" width="8" height="4" fill="%2300ff00"/><rect x="8" y="16" width="16" height="4" fill="%2300ff00"/><rect x="6" y="20" width="20" height="4" fill="%2300ff00"/><rect x="4" y="24" width="24" height="4" fill="%2300ff00"/><rect x="12" y="28" width="8" height="4" fill="%2300aa00"/><rect x="4" y="16" width="4" height="4" fill="%2300aa00"/><rect x="24" y="16" width="4" height="4" fill="%2300aa00"/><rect x="0" y="20" width="4" height="4" fill="%2300aa00"/><rect x="28" y="20" width="4" height="4" fill="%2300aa00"/></svg>');
        }

        .enemy {
            position: absolute;
            width: 24px;
            height: 24px;
            image-rendering: pixelated;
        }

        .enemy-basic {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="10" y="0" width="4" height="4" fill="%23ff0000"/><rect x="8" y="4" width="8" height="4" fill="%23ff0000"/><rect x="4" y="8" width="16" height="4" fill="%23ff0000"/><rect x="2" y="12" width="20" height="4" fill="%23ff0000"/><rect x="6" y="16" width="12" height="4" fill="%23ff0000"/><rect x="8" y="20" width="8" height="4" fill="%23ff0000"/><rect x="0" y="8" width="4" height="4" fill="%23aa0000"/><rect x="20" y="8" width="4" height="4" fill="%23aa0000"/></svg>');
        }

        .enemy-fast {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="8" y="0" width="8" height="4" fill="%23ffaa00"/><rect x="4" y="4" width="16" height="4" fill="%23ffaa00"/><rect x="6" y="8" width="12" height="4" fill="%23ffaa00"/><rect x="2" y="12" width="20" height="4" fill="%23ffaa00"/><rect x="0" y="16" width="24" height="4" fill="%23ffaa00"/><rect x="4" y="20" width="16" height="4" fill="%23ff8800"/></svg>');
        }

        .enemy-heavy {
            width: 32px;
            height: 32px;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="12" y="0" width="8" height="4" fill="%23aa00aa"/><rect x="8" y="4" width="16" height="4" fill="%23aa00aa"/><rect x="4" y="8" width="24" height="4" fill="%23aa00aa"/><rect x="0" y="12" width="32" height="8" fill="%23aa00aa"/><rect x="4" y="20" width="24" height="4" fill="%23aa00aa"/><rect x="8" y="24" width="16" height="4" fill="%23aa00aa"/><rect x="12" y="28" width="8" height="4" fill="%23880088"/></svg>');
        }

        .enemy-kamikaze {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="6" y="0" width="12" height="4" fill="%23ff4400"/><rect x="4" y="4" width="16" height="4" fill="%23ff4400"/><rect x="2" y="8" width="20" height="8" fill="%23ff4400"/><rect x="4" y="16" width="16" height="4" fill="%23ff4400"/><rect x="6" y="20" width="12" height="4" fill="%23ff2200"/><rect x="0" y="10" width="4" height="4" fill="%23ffffff"/><rect x="20" y="10" width="4" height="4" fill="%23ffffff"/></svg>');
        }

        .boss {
            position: absolute;
            width: 80px;
            height: 60px;
            image-rendering: pixelated;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="80" height="60" viewBox="0 0 80 60"><rect x="30" y="0" width="20" height="8" fill="%23ff0088"/><rect x="20" y="8" width="40" height="8" fill="%23ff0088"/><rect x="10" y="16" width="60" height="8" fill="%23ff0088"/><rect x="0" y="24" width="80" height="12" fill="%23ff0088"/><rect x="10" y="36" width="60" height="8" fill="%23ff0088"/><rect x="20" y="44" width="40" height="8" fill="%23ff0088"/><rect x="30" y="52" width="20" height="8" fill="%23cc0066"/><rect x="0" y="20" width="10" height="8" fill="%23cc0066"/><rect x="70" y="20" width="10" height="8" fill="%23cc0066"/></svg>');
        }

        .bullet {
            position: absolute;
            width: 3px;
            height: 12px;
            background: #00ffff;
            border-radius: 2px;
            box-shadow: 0 0 5px #00ffff;
        }

        .enemy-bullet {
            position: absolute;
            width: 3px;
            height: 8px;
            background: #ff4444;
            border-radius: 2px;
            box-shadow: 0 0 3px #ff4444;
        }

        .boss-bullet {
            position: absolute;
            width: 6px;
            height: 16px;
            background: #ff0088;
            border-radius: 3px;
            box-shadow: 0 0 8px #ff0088;
        }

        .powerup {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            animation: powerupFloat 2s ease-in-out infinite alternate, powerupGlow 1s ease-in-out infinite alternate;
            border: 2px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        @keyframes powerupFloat {
            0% { transform: translateY(0px) rotate(0deg); }
            100% { transform: translateY(-5px) rotate(180deg); }
        }

        @keyframes powerupGlow {
            0% { box-shadow: 0 0 5px; }
            100% { box-shadow: 0 0 15px; }
        }

        .explosion {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, #ffff00, #ff4400, #ff0000, transparent);
            animation: explode 0.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #powerupDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            text-align: right;
            font-size: 14px;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            display: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border: 2px solid #00ff00;
            border-radius: 10px;
        }

        #gameOver h2 {
            color: #ff0000;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(255, 0, 0, 0.5);
        }

        #gameOver button {
            background: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: all 0.3s;
        }

        #gameOver button:hover {
            background: #00ff00;
            color: #000;
        }

        .health-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s;
        }

        .boss-health-bar {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 15px;
            background: #333;
            border: 2px solid #ff0088;
            border-radius: 8px;
            overflow: hidden;
            display: none;
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff0088, #ff4400, #ffaa00);
            transition: width 0.3s;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 300;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #00ff00;
            border-radius: 10px;
        }

        #instructions h3 {
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 24px;
        }

        #instructions p {
            margin: 10px 0;
            font-size: 16px;
        }

        #instructions button {
            background: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: all 0.3s;
        }

        #instructions button:hover {
            background: #00ff00;
            color: #000;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.1); }
        }

        .lives-display {
            position: absolute;
            bottom: 60px;
            left: 20px;
            font-size: 18px;
            color: #00ff00;
        }

        .boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(100, 0, 0, 0.9);
            color: #ff0000;
            padding: 30px 50px;
            border: 3px solid #ff0000;
            border-radius: 15px;
            font-size: 36px;
            text-align: center;
            z-index: 500;
            animation: pulse 0.5s ease-in-out infinite alternate;
            box-shadow: 0 0 30px #ff0000;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            100% { transform: translate(-50%, -50%) scale(1.05); }
        }
    </style>
</head>
<body>
    <div id="gameCanvas">
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Wave: <span id="wave">1</span></div>
            <div>Enemies: <span id="enemyCount">0</span></div>
        </div>

        <div id="powerupDisplay">
            <div id="activePowerups"></div>
        </div>

        <div class="health-bar">
            <div class="health-fill" id="healthFill"></div>
        </div>

        <div class="boss-health-bar" id="bossHealthBar">
            <div class="boss-health-fill" id="bossHealthFill"></div>
        </div>

        <div class="lives-display">
            Lives: <span id="livesCount">3</span>
        </div>

        <div id="instructions">
            <h3>SPACE GALACTICA - ENHANCED</h3>
            <p>üöÄ Move: A/D Keys or Arrow Keys</p>
            <p>üî´ Shoot: Spacebar or Click</p>
            <p>üéØ Collect powerups for permanent upgrades!</p>
            <p>üëæ Face different enemy types and epic bosses!</p>
            <p>üíö Extra lives available - don't give up!</p>
            <button onclick="startGame()">Launch Mission</button>
        </div>

        <div id="gameOver">
            <h2>MISSION FAILED</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Completed: <span id="finalWave">0</span></p>
            <button onclick="restartGame()">Retry Mission</button>
        </div>
    </div>

    <script>
        let gameState = {
            playing: false,
            player: { 
                x: window.innerWidth / 2 - 16, 
                y: window.innerHeight - 80, 
                health: 100, 
                speed: 6,
                lives: 3
            },
            bullets: [],
            enemies: [],
            enemyBullets: [],
            explosions: [],
            powerups: [],
            permanentPowerups: {},
            score: 0,
            wave: 1,
            enemiesRemaining: 0,
            enemySpawnTimer: 0,
            keys: {},
            waveComplete: false,
            lastShoot: 0,
            boss: null,
            bossSpawnTimer: 0
        };

        // Enhanced powerup definitions - weaker but permanent
        const POWERUPS = {
            RAPID: { name: 'Rapid Fire', color: '#ff8800', symbol: 'R', fireRateBoost: 0.15 },
            SPREAD: { name: 'Spread Shot', color: '#ffff00', symbol: 'S', spreadShots: 1 },
            POWER: { name: 'Power Shot', color: '#ff0088', symbol: 'P', damageBoost: 1 },
            SPEED: { name: 'Speed Boost', color: '#00ffff', symbol: 'V', speedBoost: 1 },
            SHIELD: { name: 'Shield Gen', color: '#0088ff', symbol: 'E', shieldRegen: 5 },
            PIERCING: { name: 'Piercing', color: '#ffffff', symbol: 'X', pierce: true },
            LIFE: { name: 'Extra Life', color: '#00ff88', symbol: '+', instant: true }
        };

        // Enemy type definitions
        const ENEMY_TYPES = {
            BASIC: {
                className: 'enemy-basic',
                health: 1,
                speed: 1,
                shootRate: 0.0005,
                score: 100,
                size: 24
            },
            FAST: {
                className: 'enemy-fast',
                health: 1,
                speed: 2.5,
                shootRate: 0.0003,
                score: 150,
                size: 24
            },
            HEAVY: {
                className: 'enemy-heavy',
                health: 3,
                speed: 0.7,
                shootRate: 0.001,
                score: 300,
                size: 32
            },
            KAMIKAZE: {
                className: 'enemy-kamikaze',
                health: 1,
                speed: 3,
                shootRate: 0,
                score: 200,
                size: 24,
                kamikaze: true
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const scoreEl = document.getElementById('score');
        const waveEl = document.getElementById('wave');
        const enemyCountEl = document.getElementById('enemyCount');
        const healthFillEl = document.getElementById('healthFill');
        const livesCountEl = document.getElementById('livesCount');
        const gameOverEl = document.getElementById('gameOver');
        const instructionsEl = document.getElementById('instructions');
        const finalScoreEl = document.getElementById('finalScore');
        const finalWaveEl = document.getElementById('finalWave');
        const activePowerupsEl = document.getElementById('activePowerups');
        const bossHealthBarEl = document.getElementById('bossHealthBar');
        const bossHealthFillEl = document.getElementById('bossHealthFill');

        let lastTime = 0;

        // Create starfield
        function createStars() {
            for (let i = 0; i < 150; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * 100 + 'vw';
                star.style.top = Math.random() * 100 + 'vh';
                star.style.width = Math.random() * 3 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 2 + 's';
                canvas.appendChild(star);
            }
        }

        // Create player
        function createPlayer() {
            const player = document.createElement('div');
            player.className = 'player';
            player.id = 'player';
            player.style.left = gameState.player.x + 'px';
            player.style.top = gameState.player.y + 'px';
            canvas.appendChild(player);
        }

        // Boss functions
        function shouldSpawnBoss() {
            return gameState.wave % 5 === 0 && !gameState.boss;
        }

        function spawnBoss() {
            console.log("Spawning boss for wave", gameState.wave);
            showBossWarning();
            
            setTimeout(() => {
                const boss = {
                    x: window.innerWidth / 2 - 40,
                    y: -60,
                    targetY: 100,
                    element: document.createElement('div'),
                    health: 15 + (gameState.wave / 5) * 10,
                    maxHealth: 15 + (gameState.wave / 5) * 10,
                    lastShot: Date.now(),
                    lastSpawn: Date.now(),
                    moveDirection: 1,
                    moveTimer: 0,
                    phase: 'entering' // entering, fighting, dying
                };
                
                boss.element.className = 'boss';
                boss.element.style.left = boss.x + 'px';
                boss.element.style.top = boss.y + 'px';
                canvas.appendChild(boss.element);
                gameState.boss = boss;
                
                bossHealthBarEl.style.display = 'block';
                updateBossHealth();
            }, 3000);
        }

        function showBossWarning() {
            const warning = document.createElement('div');
            warning.className = 'boss-warning';
            warning.innerHTML = `
                <h2 style="margin: 0 0 10px 0;">‚ö†Ô∏è WARNING ‚ö†Ô∏è</h2>
                <p style="margin: 0; font-size: 24px;">BOSS APPROACHING</p>
            `;
            canvas.appendChild(warning);
            
            setTimeout(() => {
                if (warning.parentNode) {
                    warning.remove();
                }
            }, 3000);
        }

        function updateBoss(deltaTime) {
            if (!gameState.boss) return;
            
            const boss = gameState.boss;
            boss.moveTimer += deltaTime;
            
            if (boss.phase === 'entering') {
                boss.y += 2;
                if (boss.y >= boss.targetY) {
                    boss.phase = 'fighting';
                }
            } else if (boss.phase === 'fighting') {
                // Boss movement pattern
                boss.x += Math.sin(boss.moveTimer * 0.001) * 1.5;
                boss.x = Math.max(40, Math.min(window.innerWidth - 120, boss.x));
                
                // Boss shooting
                if (Date.now() - boss.lastShot > 1000) {
                    shootBossBullet(boss.x + 40, boss.y + 60);
                    boss.lastShot = Date.now();
                }
                
                // Boss spawns minions
                if (Date.now() - boss.lastSpawn > 3000) {
                    spawnBossMinion();
                    boss.lastSpawn = Date.now();
                }
            }
            
            boss.element.style.left = boss.x + 'px';
            boss.element.style.top = boss.y + 'px';
        }

        function spawnBossMinion() {
            const minionType = Math.random() < 0.7 ? 'BASIC' : 'FAST';
            const side = Math.random() < 0.5 ? -30 : window.innerWidth + 30;
            
            spawnEnemyOfType(minionType, side, gameState.boss.y + 30);
        }

        function shootBossBullet(x, y) {
            // Boss shoots multiple bullets
            for (let i = -1; i <= 1; i++) {
                const bullet = {
                    x: x + i * 20,
                    y: y,
                    element: document.createElement('div'),
                    speed: 3
                };
                
                bullet.element.className = 'boss-bullet';
                bullet.element.style.left = bullet.x + 'px';
                bullet.element.style.top = bullet.y + 'px';
                canvas.appendChild(bullet.element);
                gameState.enemyBullets.push(bullet);
            }
        }

        function updateBossHealth() {
            if (!gameState.boss) return;
            const percent = (gameState.boss.health / gameState.boss.maxHealth) * 100;
            bossHealthFillEl.style.width = Math.max(0, percent) + '%';
        }

        function destroyBoss() {
            if (!gameState.boss) return;
            
            createExplosion(gameState.boss.x + 40, gameState.boss.y + 30);
            gameState.boss.element.remove();
            gameState.boss = null;
            bossHealthBarEl.style.display = 'none';
            
            // Boss gives lots of score and guaranteed powerup
            gameState.score += 2000;
            scoreEl.textContent = gameState.score;
            
            // Spawn 2-3 powerups
            const powerupCount = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < powerupCount; i++) {
                setTimeout(() => {
                    spawnPowerup(window.innerWidth / 2 + (i - 1) * 50, 200);
                }, i * 200);
            }
            
            showBossDefeated();
        }

        function showBossDefeated() {
            const msg = document.createElement('div');
            msg.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 100, 0, 0.9);
                color: #00ff00;
                padding: 30px 50px;
                border: 3px solid #00ff00;
                border-radius: 15px;
                font-size: 32px;
                text-align: center;
                z-index: 500;
                animation: fadeInOut 4s ease-in-out forwards;
                box-shadow: 0 0 30px #00ff00;
            `;
            msg.innerHTML = `
                <h2 style="margin: 0 0 15px 0; color: #00ffff;">BOSS DEFEATED!</h2>
                <p style="margin: 0; font-size: 20px;">Outstanding pilot!</p>
            `;
            canvas.appendChild(msg);
            
            setTimeout(() => {
                if (msg.parentNode) {
                    msg.remove();
                }
            }, 4000);
        }

        // Enhanced enemy spawning
        function spawnEnemies() {
            if (shouldSpawnBoss()) {
                spawnBoss();
                return;
            }
            
            console.log("Starting enemy spawn for wave", gameState.wave);
            const baseEnemies = 4 + Math.floor(gameState.wave / 2);
            gameState.enemiesRemaining = baseEnemies;
            gameState.enemySpawnTimer = 0;
            gameState.waveComplete = false;
            enemyCountEl.textContent = baseEnemies;
            
            spawnSingleEnemy();
        }

        function spawnSingleEnemy() {
            if (gameState.enemiesRemaining <= 0) return;
            
            // Determine enemy type based on wave
            let enemyType = 'BASIC';
            const rand = Math.random();
            
            if (gameState.wave >= 3) {
                if (rand < 0.1) enemyType = 'KAMIKAZE';
                else if (rand < 0.3) enemyType = 'FAST';
                else if (rand < 0.5 && gameState.wave >= 6) enemyType = 'HEAVY';
            } else if (gameState.wave >= 2) {
                if (rand < 0.2) enemyType = 'FAST';
            }
            
            spawnEnemyOfType(enemyType, Math.random() * (window.innerWidth - 50) + 25, -40);
            gameState.enemiesRemaining--;
        }

        function spawnEnemyOfType(type, x, y) {
            const enemyData = ENEMY_TYPES[type];
            const difficultyMultiplier = 1 + (gameState.wave - 1) * 0.1;
            
            const enemy = {
                type: type,
                x: x,
                y: y,
                element: document.createElement('div'),
                lastShot: Date.now() + Math.random() * 1500,
                movePattern: Math.floor(Math.random() * 4),
                moveTimer: 0,
                health: Math.floor(enemyData.health * difficultyMultiplier),
                speed: enemyData.speed * (0.8 + Math.random() * 0.4),
                maxHealth: Math.floor(enemyData.health * difficultyMultiplier)
            };
            
            enemy.element.className = `enemy ${enemyData.className}`;
            enemy.element.style.left = enemy.x + 'px';
            enemy.element.style.top = enemy.y + 'px';
            canvas.appendChild(enemy.element);
            gameState.enemies.push(enemy);
        }

        // Shooting functions
        function shootBullet(x, y, angle = 0, speed = 8, damage = 1) {
            const bullet = {
                x: x,
                y: y,
                angle: angle,
                speed: speed,
                damage: damage,
                element: document.createElement('div')
            };
            
            bullet.element.className = 'bullet';
            bullet.element.style.left = bullet.x + 'px';
            bullet.element.style.top = bullet.y + 'px';
            canvas.appendChild(bullet.element);
            gameState.bullets.push(bullet);
        }

        function playerShoot() {
            const now = Date.now();
            const baseRate = 250;
            const rapidBonus = gameState.permanentPowerups.RAPID || 0;
            const cooldown = Math.max(100, baseRate - (rapidBonus * baseRate));
            
            if (now - gameState.lastShoot < cooldown) return;
            
            const x = gameState.player.x + 16;
            const y = gameState.player.y;
            const damage = 1 + (gameState.permanentPowerups.POWER || 0);
            const spreadLevel = gameState.permanentPowerups.SPREAD || 0;
            
            // Main shot
            shootBullet(x, y, 0, 8, damage);
            
            // Spread shots
            for (let i = 1; i <= spreadLevel; i++) {
                shootBullet(x - i * 15, y, -i * 0.2, 8, damage);
                shootBullet(x + i * 15, y, i * 0.2, 8, damage);
            }
            
            gameState.lastShoot = now;
        }

        function enemyShoot(enemy) {
            const enemyData = ENEMY_TYPES[enemy.type];
            if (!enemyData.shootRate || Date.now() - enemy.lastShot < 2000 + Math.random() * 2000) return;
            if (enemy.y < 50 || enemy.y > window.innerHeight - 200) return;
            
            const bullet = {
                x: enemy.x + enemyData.size / 2,
                y: enemy.y + enemyData.size,
                element: document.createElement('div'),
                speed: 3 + Math.random() * 2
            };
            
            bullet.element.className = 'enemy-bullet';
            bullet.element.style.left = bullet.x + 'px';
            bullet.element.style.top = bullet.y + 'px';
            canvas.appendChild(bullet.element);
            gameState.enemyBullets.push(bullet);
            enemy.lastShot = Date.now();
        }

        // Powerup functions
        function spawnPowerup(x, y) {
            if (Math.random() < 0.4) { // 40% chance
                const powerupKeys = Object.keys(POWERUPS);
                const powerupType = powerupKeys[Math.floor(Math.random() * powerupKeys.length)];
                const powerupData = POWERUPS[powerupType];
                
                const powerup = {
                    x: x,
                    y: y,
                    type: powerupType,
                    element: document.createElement('div')
                };
                
                powerup.element.className = 'powerup';
                powerup.element.style.left = powerup.x + 'px';
                powerup.element.style.top = powerup.y + 'px';
                powerup.element.style.background = powerupData.color;
                powerup.element.style.borderColor = powerupData.color;
                powerup.element.style.color = '#000';
                powerup.element.textContent = powerupData.symbol;
                
                canvas.appendChild(powerup.element);
                gameState.powerups.push(powerup);
            }
        }

        function activatePowerup(type) {
            const powerup = POWERUPS[type];
            
            if (powerup.instant) {
                if (type === 'LIFE') {
                    gameState.player.lives++;
                    livesCountEl.textContent = gameState.player.lives;
                    showLifeGained();
                }
            } else {
                // Permanent powerup - stack levels
                if (!gameState.permanentPowerups[type]) {
                    gameState.permanentPowerups[type] = 0;
                }
                gameState.permanentPowerups[type] += 1;
                
                // Cap certain powerups
                if (type === 'SPREAD' && gameState.permanentPowerups[type] > 3) {
                    gameState.permanentPowerups[type] = 3;
                }
                if (type === 'RAPID' && gameState.permanentPowerups[type] > 0.7) {
                    gameState.permanentPowerups[type] = 0.7;
                }
                if (type === 'SPEED' && gameState.permanentPowerups[type] > 4) {
                    gameState.permanentPowerups[type] = 4;
                }
                
                updatePowerupDisplay();
                showPowerupGained(powerup.name);
            }
        }

        function showLifeGained() {
            const msg = document.createElement('div');
            msg.style.cssText = `
                position: absolute;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 100, 0, 0.9);
                color: #00ff88;
                padding: 20px 40px;
                border: 2px solid #00ff88;
                border-radius: 10px;
                font-size: 24px;
                text-align: center;
                z-index: 500;
                animation: fadeInOut 2s ease-in-out forwards;
            `;
            msg.innerHTML = `<strong>EXTRA LIFE!</strong>`;
            canvas.appendChild(msg);
            
            setTimeout(() => {
                if (msg.parentNode) {
                    msg.remove();
                }
            }, 2000);
        }

        function showPowerupGained(name) {
            const msg = document.createElement('div');
            msg.style.cssText = `
                position: absolute;
                top: 70%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 50, 100, 0.8);
                color: #00ffff;
                padding: 15px 30px;
                border: 2px solid #00ffff;
                border-radius: 8px;
                font-size: 18px;
                text-align: center;
                z-index: 500;
                animation: fadeInOut 2s ease-in-out forwards;
            `;
            msg.innerHTML = `${name} Upgraded!`;
            canvas.appendChild(msg);
            
            setTimeout(() => {
                if (msg.parentNode) {
                    msg.remove();
                }
            }, 2000);
        }

        function updatePowerupDisplay() {
            let html = '<div style="color: #ffff00; font-size: 16px; margin-bottom: 10px;">PERMANENT UPGRADES:</div>';
            
            Object.keys(gameState.permanentPowerups).forEach(type => {
                const level = gameState.permanentPowerups[type];
                const powerup = POWERUPS[type];
                if (level > 0) {
                    html += `<div style="color: ${powerup.color};">${powerup.name} Lv.${level}</div>`;
                }
            });
            
            activePowerupsEl.innerHTML = html;
        }

        // Explosion
        function createExplosion(x, y, size = 50) {
            const explosion = {
                x: x,
                y: y,
                element: document.createElement('div'),
                timer: 500
            };
            
            explosion.element.className = 'explosion';
            explosion.element.style.width = size + 'px';
            explosion.element.style.height = size + 'px';
            explosion.element.style.left = (x - size/2) + 'px';
            explosion.element.style.top = (y - size/2) + 'px';
            canvas.appendChild(explosion.element);
            gameState.explosions.push(explosion);
        }

        // Collision detection
        function checkCollision(obj1, obj2, size1 = 24, size2 = 24) {
            return obj1.x < obj2.x + size2 &&
                   obj1.x + size1 > obj2.x &&
                   obj1.y < obj2.y + size2 &&
                   obj1.y + size1 > obj2.y;
        }

        // Player death and respawn
        function playerDeath() {
            gameState.player.lives--;
            livesCountEl.textContent = gameState.player.lives;
            
            if (gameState.player.lives <= 0) {
                endGame();
                return;
            }
            
            // Respawn with brief invulnerability
            gameState.player.health = 100;
            gameState.player.x = window.innerWidth / 2 - 16;
            gameState.player.invulnerable = Date.now() + 3000; // 3 seconds
            healthFillEl.style.width = '100%';
            
            showRespawnMessage();
        }

        function showRespawnMessage() {
            const msg = document.createElement('div');
            msg.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(100, 100, 0, 0.9);
                color: #ffff00;
                padding: 20px 40px;
                border: 2px solid #ffff00;
                border-radius: 10px;
                font-size: 20px;
                text-align: center;
                z-index: 500;
                animation: fadeInOut 3s ease-in-out forwards;
            `;
            msg.innerHTML = `
                <strong>RESPAWNING</strong><br>
                <small>Temporary shield active</small>
            `;
            canvas.appendChild(msg);
            
            setTimeout(() => {
                if (msg.parentNode) {
                    msg.remove();
                }
            }, 3000);
        }

        // Update game
        function updateGame(deltaTime) {
            if (!gameState.playing) return;

            const playerEl = document.getElementById('player');
            
            // Player movement with speed upgrades
            const moveSpeed = gameState.player.speed + (gameState.permanentPowerups.SPEED || 0);
            if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) {
                gameState.player.x -= moveSpeed;
            }
            if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) {
                gameState.player.x += moveSpeed;
            }
            
            gameState.player.x = Math.max(0, Math.min(window.innerWidth - 32, gameState.player.x));
            playerEl.style.left = gameState.player.x + 'px';
            
            // Show invulnerability effect
            if (gameState.player.invulnerable && Date.now() < gameState.player.invulnerable) {
                playerEl.style.opacity = Math.sin(Date.now() / 100) > 0 ? '0.3' : '1';
            } else {
                playerEl.style.opacity = '1';
                gameState.player.invulnerable = null;
            }

            // Auto-shoot if holding space
            if (gameState.keys['Space']) {
                playerShoot();
            }

            // Health regeneration from shield powerup
            const shieldRegen = gameState.permanentPowerups.SHIELD || 0;
            if (shieldRegen > 0 && gameState.player.health < 100) {
                gameState.player.health = Math.min(100, gameState.player.health + shieldRegen * deltaTime / 1000);
                healthFillEl.style.width = gameState.player.health + '%';
            }

            // Update boss
            updateBoss(deltaTime);

            // Enemy spawning
            if (!gameState.boss) {
                gameState.enemySpawnTimer += deltaTime;
                const spawnRate = Math.max(300, 1000 - (gameState.wave * 40));
                
                if (gameState.enemySpawnTimer > spawnRate && gameState.enemiesRemaining > 0) {
                    spawnSingleEnemy();
                    gameState.enemySpawnTimer = 0;
                }
            }

            // Update bullets
            gameState.bullets = gameState.bullets.filter(bullet => {
                bullet.y -= bullet.speed;
                bullet.x += Math.sin(bullet.angle) * bullet.speed;
                bullet.element.style.top = bullet.y + 'px';
                bullet.element.style.left = bullet.x + 'px';
                
                if (bullet.y < -20 || bullet.x < -20 || bullet.x > window.innerWidth + 20) {
                    bullet.element.remove();
                    return false;
                }
                
                // Check boss collision
                if (gameState.boss && checkCollision(bullet, gameState.boss, 6, 80)) {
                    gameState.boss.health -= bullet.damage;
                    updateBossHealth();
                    
                    if (gameState.boss.health <= 0) {
                        destroyBoss();
                    }
                    
                    if (!gameState.permanentPowerups.PIERCING) {
                        bullet.element.remove();
                        return false;
                    }
                }
                
                // Check enemy collisions
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    const enemyData = ENEMY_TYPES[enemy.type];
                    
                    if (checkCollision(bullet, enemy, 6, enemyData.size)) {
                        enemy.health -= bullet.damage;
                        
                        if (enemy.health <= 0) {
                            createExplosion(enemy.x + enemyData.size/2, enemy.y + enemyData.size/2);
                            spawnPowerup(enemy.x + enemyData.size/2, enemy.y + enemyData.size/2);
                            enemy.element.remove();
                            gameState.enemies.splice(i, 1);
                            gameState.score += enemyData.score;
                            scoreEl.textContent = gameState.score;
                        }
                        
                        if (!gameState.permanentPowerups.PIERCING) {
                            bullet.element.remove();
                            return false;
                        }
                    }
                }
                
                return true;
            });

            // Update enemy bullets
            gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                const speed = bullet.speed || 4;
                bullet.y += speed;
                bullet.element.style.top = bullet.y + 'px';
                
                if (bullet.y > window.innerHeight + 20) {
                    bullet.element.remove();
                    return false;
                }
                
                // Check player collision (with invulnerability)
                const isInvulnerable = gameState.player.invulnerable && Date.now() < gameState.player.invulnerable;
                if (checkCollision(bullet, gameState.player, 6, 32) && !isInvulnerable) {
                    createExplosion(gameState.player.x + 16, gameState.player.y + 16);
                    bullet.element.remove();
                    gameState.player.health -= 15;
                    healthFillEl.style.width = Math.max(0, gameState.player.health) + '%';
                    
                    if (gameState.player.health <= 0) {
                        playerDeath();
                    }
                    return false;
                }
                
                return true;
            });

            // Update enemies
            gameState.enemies.forEach((enemy, index) => {
                const enemyData = ENEMY_TYPES[enemy.type];
                enemy.moveTimer += deltaTime;
                enemy.y += enemy.speed;
                
                // Special kamikaze behavior
                if (enemy.type === 'KAMIKAZE' && enemy.y > window.innerHeight / 2) {
                    const dx = gameState.player.x - enemy.x;
                    enemy.x += Math.sign(dx) * 2;
                }
                
                // Enhanced movement patterns
                const intensity = 1 + (gameState.wave - 1) * 0.3;
                switch (enemy.movePattern) {
                    case 0:
                        enemy.x += (Math.random() - 0.5) * 0.5 * intensity;
                        break;
                    case 1:
                        enemy.x += Math.sin(enemy.moveTimer * 0.005) * 2 * intensity;
                        break;
                    case 2:
                        enemy.x += Math.sin(enemy.moveTimer * 0.002) * 1.5 * intensity;
                        break;
                    case 3:
                        enemy.x += Math.sin(enemy.moveTimer * 0.008) * 3 * intensity;
                        break;
                }
                
                enemy.x = Math.max(0, Math.min(window.innerWidth - enemyData.size, enemy.x));
                
                // Check collision with player (kamikaze)
                if (enemy.type === 'KAMIKAZE' && checkCollision(enemy, gameState.player, enemyData.size, 32)) {
                    const isInvulnerable = gameState.player.invulnerable && Date.now() < gameState.player.invulnerable;
                    if (!isInvulnerable) {
                        createExplosion(enemy.x + enemyData.size/2, enemy.y + enemyData.size/2, 70);
                        gameState.player.health -= 25;
                        healthFillEl.style.width = Math.max(0, gameState.player.health) + '%';
                        
                        if (gameState.player.health <= 0) {
                            playerDeath();
                        }
                    }
                    
                    enemy.element.remove();
                    gameState.enemies.splice(index, 1);
                    gameState.score += enemyData.score;
                    scoreEl.textContent = gameState.score;
                    return;
                }
                
                // Remove enemies that go off screen
                if (enemy.y > window.innerHeight + 50) {
                    enemy.element.remove();
                    gameState.enemies.splice(index, 1);
                    return;
                }
                
                enemy.element.style.left = enemy.x + 'px';
                enemy.element.style.top = enemy.y + 'px';
                
                // Enemy shooting
                if (Math.random() < enemyData.shootRate * deltaTime) {
                    enemyShoot(enemy);
                }
            });

            // Update powerups
            gameState.powerups = gameState.powerups.filter(powerup => {
                powerup.y += 3;
                powerup.element.style.top = powerup.y + 'px';
                
                if (powerup.y > window.innerHeight + 50) {
                    powerup.element.remove();
                    return false;
                }
                
                if (checkCollision(powerup, gameState.player, 20, 32)) {
                    activatePowerup(powerup.type);
                    powerup.element.remove();
                    return false;
                }
                
                return true;
            });

            // Update explosions
            gameState.explosions = gameState.explosions.filter(explosion => {
                explosion.timer -= deltaTime;
                if (explosion.timer <= 0) {
                    explosion.element.remove();
                    return false;
                }
                return true;
            });

            enemyCountEl.textContent = gameState.enemies.length + gameState.enemiesRemaining;

            // Check wave completion
            const waveComplete = gameState.enemiesRemaining <= 0 && 
                                gameState.enemies.length === 0 && 
                                !gameState.boss && 
                                !gameState.waveComplete;
            
            if (waveComplete) {
                gameState.waveComplete = true;
                showWaveComplete();
                setTimeout(() => nextWave(), 3000);
            }
        }

        // Wave progression
        function nextWave() {
            gameState.wave++;
            gameState.player.health = Math.min(100, gameState.player.health + 20);
            waveEl.textContent = gameState.wave;
            healthFillEl.style.width = gameState.player.health + '%';
            
            setTimeout(() => {
                spawnEnemies();
            }, 1000);
        }

        function showWaveComplete() {
            const waveMsg = document.createElement('div');
            waveMsg.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 50, 0, 0.9);
                color: #00ff00;
                padding: 30px 50px;
                border: 3px solid #00ff00;
                border-radius: 15px;
                font-size: 28px;
                text-align: center;
                z-index: 500;
                animation: fadeInOut 3s ease-in-out forwards;
                box-shadow: 0 0 20px #00ff00;
            `;
            waveMsg.innerHTML = `
                <h2 style="margin: 0 0 10px 0; color: #00ffff;">WAVE ${gameState.wave} CLEARED!</h2>
                <p style="margin: 0; font-size: 18px;">Preparing next assault wave...</p>
            `;
            canvas.appendChild(waveMsg);
            
            setTimeout(() => {
                if (waveMsg.parentNode) {
                    waveMsg.remove();
                }
            }, 3000);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.code] = true;
            
            if (e.code === 'Space' && gameState.playing) {
                e.preventDefault();
                playerShoot();
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.code] = false;
        });

        canvas.addEventListener('click', (e) => {
            if (gameState.playing) {
                playerShoot();
            }
        });

        // Game functions
        function startGame() {
            instructionsEl.style.display = 'none';
            gameState.playing = true;
            gameState.player.x = window.innerWidth / 2 - 16;
            gameState.player.y = window.innerHeight - 80;
            gameState.player.health = 100;
            gameState.player.lives = 3;
            gameState.score = 0;
            gameState.wave = 1;
            gameState.waveComplete = false;
            gameState.boss = null;
            
            scoreEl.textContent = gameState.score;
            waveEl.textContent = '1';
            livesCountEl.textContent = gameState.player.lives;
            healthFillEl.style.width = '100%';
            bossHealthBarEl.style.display = 'none';
            updatePowerupDisplay();
            
            createPlayer();
            
            setTimeout(() => {
                spawnEnemies();
            }, 500);
            
            gameLoop();
        }

        function endGame() {
            gameState.playing = false;
            finalScoreEl.textContent = gameState.score;
            finalWaveEl.textContent = gameState.wave;
            gameOverEl.style.display = 'block';
        }

        function restartGame() {
            // Clear all game objects
            gameState.bullets.forEach(bullet => bullet.element.remove());
            gameState.enemies.forEach(enemy => enemy.element.remove());
            gameState.enemyBullets.forEach(bullet => bullet.element.remove());
            gameState.explosions.forEach(explosion => explosion.element.remove());
            gameState.powerups.forEach(powerup => powerup.element.remove());
            
            if (gameState.boss) {
                gameState.boss.element.remove();
            }
            
            const playerEl = document.getElementById('player');
            if (playerEl) playerEl.remove();
            
            // Reset game state but keep permanent powerups
            gameState = {
                playing: false,
                player: { 
                    x: window.innerWidth / 2 - 16, 
                    y: window.innerHeight - 80, 
                    health: 100, 
                    speed: 6,
                    lives: 3
                },
                bullets: [],
                enemies: [],
                enemyBullets: [],
                explosions: [],
                powerups: [],
                permanentPowerups: {}, // Reset permanent powerups on game restart
                score: 0,
                wave: 1,
                enemiesRemaining: 0,
                enemySpawnTimer: 0,
                keys: {},
                waveComplete: false,
                lastShoot: 0,
                boss: null,
                bossSpawnTimer: 0
            };
            
            gameOverEl.style.display = 'none';
            instructionsEl.style.display = 'block';
            bossHealthBarEl.style.display = 'none';
            activePowerupsEl.innerHTML = '';
        }

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            updateGame(deltaTime);
            if (gameState.playing) {
                requestAnimationFrame(gameLoop);
            }
        }

        // Initialize game
        createStars();
    </script>
</body>
</html>