<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Galactica - Ultimate Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #gameCanvas {
            background: radial-gradient(ellipse at center, #001122 0%, #000000 100%);
            position: relative;
            width: 1000px;
            height: 800px;
            cursor: default;
            border: 5px solid #00ff00;
            box-shadow: 0 0 20px #00ff00;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 2s infinite alternate;
        }

        @keyframes twinkle {
            0% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        .player {
            position: absolute;
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
            transition: transform 0.3s;
            outline: 1px solid white;
        }

        .companion {
            width: 24px;
            height: 24px;
            outline: 1px solid white;
        }

        .enemy {
            position: absolute;
            width: 24px;
            height: 24px;
            image-rendering: pixelated;
        }

        .enemy-basic {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="10" y="0" width="4" height="4" fill="%23ff0000"/><rect x="8" y="4" width="8" height="4" fill="%23ff0000"/><rect x="4" y="8" width="16" height="4" fill="%23ff0000"/><rect x="2" y="12" width="20" height="4" fill="%23ff0000"/><rect x="6" y="16" width="12" height="4" fill="%23ff0000"/><rect x="8" y="20" width="8" height="4" fill="%23ff0000"/><rect x="0" y="8" width="4" height="4" fill="%23aa0000"/><rect x="20" y="8" width="4" height="4" fill="%23aa0000"/></svg>');
        }

        .enemy-fast {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="8" y="0" width="8" height="4" fill="%23ffaa00"/><rect x="4" y="4" width="16" height="4" fill="%23ffaa00"/><rect x="6" y="8" width="12" height="4" fill="%23ffaa00"/><rect x="2" y="12" width="20" height="4" fill="%23ffaa00"/><rect x="0" y="16" width="24" height="4" fill="%23ffaa00"/><rect x="4" y="20" width="16" height="4" fill="%23ff8800"/></svg>');
        }

        .enemy-heavy {
            width: 32px;
            height: 32px;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="12" y="0" width="8" height="4" fill="%23aa00aa"/><rect x="8" y="4" width="16" height="4" fill="%23aa00aa"/><rect x="4" y="8" width="24" height="4" fill="%23aa00aa"/><rect x="0" y="12" width="32" height="8" fill="%23aa00aa"/><rect x="4" y="20" width="24" height="4" fill="%23aa00aa"/><rect x="8" y="24" width="16" height="4" fill="%23aa00aa"/><rect x="12" y="28" width="8" height="4" fill="%23880088"/></svg>');
        }

        .enemy-kamikaze {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="6" y="0" width="12" height="4" fill="%23ff4400"/><rect x="4" y="4" width="16" height="4" fill="%23ff4400"/><rect x="2" y="8" width="20" height="8" fill="%23ff4400"/><rect x="4" y="16" width="16" height="4" fill="%23ff4400"/><rect x="6" y="20" width="12" height="4" fill="%23ff2200"/><rect x="0" y="10" width="4" height="4" fill="%23ffffff"/><rect x="20" y="10" width="4" height="4" fill="%23ffffff"/></svg>');
        }

        .enemy-sniper {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="10" y="0" width="4" height="8" fill="%2300aaff"/><rect x="8" y="8" width="8" height="4" fill="%2300aaff"/><rect x="6" y="12" width="12" height="4" fill="%2300aaff"/><rect x="4" y="16" width="16" height="4" fill="%2300aaff"/><rect x="8" y="20" width="8" height="4" fill="%230088cc"/><rect x="0" y="12" width="6" height="4" fill="%230088cc"/><rect x="18" y="12" width="6" height="4" fill="%230088cc"/></svg>');
        }

        .enemy-bomber {
            width: 28px;
            height: 28px;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><rect x="12" y="0" width="4" height="6" fill="%2300ff88"/><rect x="8" y="6" width="12" height="4" fill="%2300ff88"/><rect x="4" y="10" width="20" height="8" fill="%2300ff88"/><rect x="6" y="18" width="16" height="4" fill="%2300ff88"/><rect x="10" y="22" width="8" height="6" fill="%2300cc66"/><rect x="0" y="14" width="4" height="4" fill="%23ffffff"/><rect x="24" y="14" width="4" height="4" fill="%23ffffff"/></svg>');
        }

        .enemy-shield {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="8" y="0" width="8" height="4" fill="%23888888"/><rect x="4" y="4" width="16" height="4" fill="%23888888"/><rect x="2" y="8" width="20" height="8" fill="%23888888"/><rect x="4" y="16" width="16" height="4" fill="%23888888"/><rect x="8" y="20" width="8" height="4" fill="%23666666"/><rect x="10" y="8" width="4" height="8" fill="%23aaaaaa"/></svg>');
        }

        .enemy-spawner {
            width: 36px;
            height: 24px;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="36" height="24" viewBox="0 0 36 24"><rect x="14" y="0" width="8" height="4" fill="%23aa88ff"/><rect x="10" y="4" width="16" height="4" fill="%23aa88ff"/><rect x="6" y="8" width="24" height="8" fill="%23aa88ff"/><rect x="10" y="16" width="16" height="4" fill="%23aa88ff"/><rect x="14" y="20" width="8" height="4" fill="%238866cc"/><rect x="0" y="10" width="6" height="4" fill="%238866cc"/><rect x="30" y="10" width="6" height="4" fill="%238866cc"/></svg>');
        }

        .enemy-berserker {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="8" y="0" width="8" height="4" fill="%23ff0088"/><rect x="4" y="4" width="16" height="4" fill="%23ff0088"/><rect x="0" y="8" width="24" height="8" fill="%23ff0088"/><rect x="4" y="16" width="16" height="4" fill="%23ff0088"/><rect x="8" y="20" width="8" height="4" fill="%23cc0066"/><rect x="0" y="0" width="4" height="4" fill="%23ffffff"/><rect x="20" y="0" width="4" height="4" fill="%23ffffff"/></svg>');
        }

        .enemy-teleporter {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="10" y="0" width="4" height="4" fill="%23ff88ff"/><rect x="8" y="4" width="8" height="4" fill="%23ff88ff"/><rect x="6" y="8" width="12" height="8" fill="%23ff88ff"/><rect x="8" y="16" width="8" height="4" fill="%23ff88ff"/><rect x="10" y="20" width="4" height="4" fill="%23cc44cc"/><rect x="2" y="10" width="4" height="4" fill="%23ffffff"/><rect x="18" y="10" width="4" height="4" fill="%23ffffff"/></svg>');
        }

        .enemy-laser {
            width: 28px;
            height: 20px;
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="20" viewBox="0 0 28 20"><rect x="10" y="0" width="8" height="4" fill="%23ff4444"/><rect x="6" y="4" width="16" height="4" fill="%23ff4444"/><rect x="2" y="8" width="24" height="4" fill="%23ff4444"/><rect x="6" y="12" width="16" height="4" fill="%23ff4444"/><rect x="10" y="16" width="8" height="4" fill="%23cc2222"/><rect x="0" y="9" width="2" height="2" fill="%23ffffff"/><rect x="26" y="9" width="2" height="2" fill="%23ffffff"/></svg>');
        }

        .enemy-stealth {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="10" y="2" width="4" height="4" fill="%2344ff44" opacity="0.7"/><rect x="8" y="6" width="8" height="4" fill="%2344ff44" opacity="0.7"/><rect x="6" y="10" width="12" height="4" fill="%2244ff44" opacity="0.7"/><rect x="8" y="14" width="8" height="4" fill="%2244ff44" opacity="0.7"/><rect x="10" y="18" width="4" height="4" fill="%2222cc22" opacity="0.7"/></svg>');
        }

        .enemy-zigzag {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="8" y="0" width="8" height="4" fill="%23ffff44"/><rect x="4" y="4" width="16" height="4" fill="%23ffff44"/><rect x="2" y="8" width="20" height="8" fill="%23ffff44"/><rect x="4" y="16" width="16" height="4" fill="%23ffff44"/><rect x="8" y="20" width="8" height="4" fill="%23cccc22"/><rect x="0" y="4" width="4" height="4" fill="%23ffffff"/><rect x="20" y="16" width="4" height="4" fill="%23ffffff"/></svg>');
        }

        .enemy-homing {
            background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><rect x="10" y="0" width="4" height="4" fill="%23ff00ff"/><rect x="8" y="4" width="8" height="4" fill="%23ff00ff"/><rect x="6" y="8" width="12" height="8" fill="%23ff00ff"/><rect x="8" y="16" width="8" height="4" fill="%23ff00ff"/><rect x="10" y="20" width="4" height="4" fill="%23cc00cc"/><rect x="2" y="10" width="4" height="4" fill="%23ffffff"/><rect x="18" y="10" width="4" height="4" fill="%23ffffff"/></svg>');
        }

        .boss {
            position: absolute;
            width: 80px;
            height: 60px;
            image-rendering: pixelated;
        }

        .bullet {
            position: absolute;
            width: 3px;
            height: 12px;
            background: #00ffff;
            border-radius: 2px;
            box-shadow: 0 0 5px #00ffff;
        }

        .enemy-bullet {
            position: absolute;
            width: 3px;
            height: 8px;
            background: #ff4444;
            border-radius: 2px;
            box-shadow: 0 0 3px #ff4444;
        }

        .boss-bullet {
            position: absolute;
            width: 6px;
            height: 16px;
            background: #ff0088;
            border-radius: 3px;
            box-shadow: 0 0 8px #ff0088;
        }

        .laser-beam {
            position: absolute;
            width: 4px;
            background: linear-gradient(to bottom, #ff0000, #ffaa00);
            border-radius: 2px;
            box-shadow: 0 0 10px #ff0000;
            animation: pulse 0.1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scaleX(1); opacity: 1; }
            50% { transform: scaleX(1.5); opacity: 0.8; }
        }

        .powerup {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            animation: powerupFloat 2s ease-in-out infinite alternate, powerupGlow 1s ease-in-out infinite alternate;
            border: 3px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .powerup-permanent {
            border-color: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }

        .powerup-temporary {
            border-color: #aa44ff;
            box-shadow: 0 0 10px #aa44ff;
        }

        @keyframes powerupFloat {
            0% { transform: translateY(0px) rotate(0deg); }
            100% { transform: translateY(-5px) rotate(180deg); }
        }

        @keyframes powerupGlow {
            0% { box-shadow: 0 0 5px; }
            100% { box-shadow: 0 0 15px; }
        }

        .explosion {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, #ffff00, #ff4400, #ff0000, transparent);
            animation: explode 0.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes explode {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #powerupDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            text-align: right;
            font-size: 14px;
        }

        #highScores {
            position: absolute;
            top: 120px;
            left: 20px;
            z-index: 100;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            display: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border: 2px solid #00ff00;
            border-radius: 10px;
        }

        #gameOver h2 {
            color: #ff0000;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(255, 0, 0, 0.5);
        }

        #gameOver button {
            background: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: all 0.3s;
        }

        #gameOver button:hover {
            background: #00ff00;
            color: #000;
        }

        .health-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff0000, #ffff00, #00ff00);
            transition: width 0.3s;
        }

        .boss-health-bar {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 15px;
            background: #333;
            border: 2px solid #ff0088;
            border-radius: 8px;
            overflow: hidden;
            display: none;
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff0088, #ff4400, #ffaa00);
            transition: width 0.3s;
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 300;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #00ff00;
            border-radius: 10px;
        }

        #instructions h3 {
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 24px;
        }

        #instructions p {
            margin: 10px 0;
            font-size: 16px;
        }

        #instructions button {
            background: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 5px;
            margin-top: 20px;
            transition: all 0.3s;
        }

        #instructions button:hover {
            background: #00ff00;
            color: #000;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.1); }
        }

        .lives-display {
            position: absolute;
            bottom: 60px;
            left: 20px;
            font-size: 18px;
            color: #00ff00;
        }

        .boss-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(100, 0, 0, 0.9);
            color: #ff0000;
            padding: 30px 50px;
            border: 3px solid #ff0000;
            border-radius: 15px;
            font-size: 36px;
            text-align: center;
            z-index: 500;
            animation: pulse 0.5s ease-in-out infinite alternate;
            box-shadow: 0 0 30px #ff0000;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            100% { transform: translate(-50%, -50%) scale(1.05); }
        }

        .temp-powerup-timer {
            position: absolute;
            bottom: 100px;
            left: 20px;
            z-index: 100;
            font-size: 16px;
            color: #aa44ff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        @keyframes fadeUp {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        #pauseBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 5px 10px;
            font-size: 14px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            z-index: 100;
        }

        #pauseBtn:hover {
            background: #00ff00;
            color: #000;
        }

        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 200;
            display: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 40px;
            border: 2px solid #00ff00;
            border-radius: 10px;
        }

        #pauseMenu h2 {
            color: #00ffff;
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 255, 0.5);
        }

        #pauseMenu button {
            background: #003300;
            color: #00ff00;
            border: 2px solid #00ff00;
            padding: 10px 20px;
            font-size: 18px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 5px;
            margin: 10px;
            transition: all 0.3s;
        }

        #pauseMenu button:hover {
            background: #00ff00;
            color: #000;
        }
    </style>
</head>
<body>
    <div id="gameCanvas">
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Wave: <span id="wave">1</span></div>
            <div>Enemies: <span id="enemyCount">0</span></div>
        </div>

        <div id="highScores">
            <div>High Score: <span id="highScore">0</span></div>
            <div>Top Wave: <span id="topWave">1</span></div>
        </div>

        <div id="powerupDisplay">
            <div id="activePowerups"></div>
        </div>

        <button id="pauseBtn">Pause</button>

        <div class="health-bar">
            <div class="health-fill" id="healthFill"></div>
        </div>

        <div class="boss-health-bar" id="bossHealthBar">
            <div class="boss-health-fill" id="bossHealthFill"></div>
        </div>

        <div class="lives-display">
            Lives: <span id="livesCount">3</span>
        </div>

        <div class="temp-powerup-timer" id="tempPowerupTimer"></div>

        <div id="instructions">
            <h3>SPACE GALACTICA - ULTIMATE EDITION</h3>
            <p>🚀 Move: A/D Keys or Arrow Keys</p>
            <p>🔫 Shoot: Spacebar or Click</p>
            <p>🟢 Green Powerups: Permanent upgrades!</p>
            <p>🟣 Purple Powerups: Temporary super boosts!</p>
            <p>👾 Face 12+ enemy types and epic bosses!</p>
            <p>💚 Extra lives are extremely rare - treasure them!</p>
            <button onclick="startGame()">Launch Mission</button>
        </div>

        <div id="gameOver">
            <h2>MISSION FAILED</h2>
            <p>Final Score: <span id="finalScore">0</span></p>
            <p>Waves Completed: <span id="finalWave">0</span></p>
            <p id="newRecord" style="color: #ffff00; font-size: 20px; display: none;">NEW RECORD!</p>
            <button onclick="restartGame()">Retry Mission</button>
        </div>

        <div id="pauseMenu">
            <h2>PAUSED</h2>
            <button onclick="resumeGame()">Resume</button>
            <button onclick="restartGame()">Restart Mission</button>
        </div>
    </div>

    <script>
        let gameState = {
            playing: false,
            paused: false,
            player: { 
                x: 0, 
                y: 0, 
                health: 100, 
                speed: 6,
                lives: 3
            },
            bullets: [],
            enemies: [],
            enemyBullets: [],
            explosions: [],
            powerups: [],
            permanentPowerups: {},
            temporaryPowerups: {},
            tempPowerupTimer: {},
            score: 0,
            wave: 1,
            enemiesRemaining: 0,
            enemySpawnTimer: 0,
            keys: {},
            waveComplete: false,
            lastShoot: 0,
            boss: null,
            bossSpawnTimer: 0,
            laserBeams: [],
            companions: []
        };

        // High scores
        let highScore = localStorage.getItem('spaceGalacticaHighScore') || 0;
        let topWave = localStorage.getItem('spaceGalacticaTopWave') || 1;

        // Enhanced powerup definitions
        const POWERUPS = {
            // Permanent powerups (green ring)
            RAPID: { name: 'Rapid Fire', color: '#ff8800', symbol: 'R', fireRateBoost: 0.15, permanent: true },
            SPREAD: { name: 'Spread Shot', color: '#ffff00', symbol: 'S', spreadShots: 1, permanent: true },
            POWER: { name: 'Power Shot', color: '#ff0088', symbol: 'P', damageBoost: 1, permanent: true },
            SPEED: { name: 'Speed Boost', color: '#00ffff', symbol: 'V', speedBoost: 1, permanent: true },
            SHIELD: { name: 'Shield Gen', color: '#0088ff', symbol: 'E', shieldRegen: 5, permanent: true },
            PIERCING: { name: 'Piercing', color: '#ffffff', symbol: 'X', pierce: true, permanent: true },
            LIFE: { name: 'Extra Life', color: '#00ff88', symbol: '+', instant: true, permanent: true },
            
            // Temporary powerups (purple ring) - super powerful but short duration
            MEGA_RAPID: { name: 'Mega Rapid', color: '#ff4400', symbol: 'M', fireRateBoost: 0.9, permanent: false, duration: 15000 },
            SUPER_SPREAD: { name: 'Super Spread', color: '#44ff44', symbol: 'U', spreadShots: 5, permanent: false, duration: 12000 },
            TRIPLE_DAMAGE: { name: 'Triple Damage', color: '#ff44ff', symbol: 'T', damageBoost: 5, permanent: false, duration: 10000 },
            INVINCIBLE: { name: 'Invincible', color: '#ffff44', symbol: 'I', invincible: true, permanent: false, duration: 8000 },
            TIME_SLOW: { name: 'Time Slow', color: '#8844ff', symbol: 'Z', timeSlow: true, permanent: false, duration: 15000 },
            COMPANION: { name: 'Wingman', color: '#8800ff', symbol: 'W', permanent: true },
            HEALTH_PACK: { name: 'Health Pack', color: '#00ff88', symbol: 'HP', instant: true, permanent: false },
            DOUBLE_SCORE: { name: 'Double Score', color: '#ffff00', symbol: 'D', permanent: false, duration: 15000 },
            NUKES: { name: 'Nuke', color: '#ff0000', symbol: 'N', instant: true, permanent: false }
        };

        // Enhanced enemy type definitions with wave requirements
        const ENEMY_TYPES = {
            BASIC: {
                className: 'enemy-basic',
                health: 1,
                speed: 1,
                shootRate: 0.0005,
                score: 100,
                size: 24,
                minWave: 1
            },
            FAST: {
                className: 'enemy-fast',
                health: 1,
                speed: 2.5,
                shootRate: 0.0003,
                score: 150,
                size: 24,
                minWave: 2
            },
            HEAVY: {
                className: 'enemy-heavy',
                health: 3,
                speed: 0.7,
                shootRate: 0.001,
                score: 300,
                size: 32,
                minWave: 4
            },
            KAMIKAZE: {
                className: 'enemy-kamikaze',
                health: 1,
                speed: 3,
                shootRate: 0,
                score: 200,
                size: 24,
                kamikaze: true,
                minWave: 3
            },
            SNIPER: {
                className: 'enemy-sniper',
                health: 2,
                speed: 0.5,
                shootRate: 0.002,
                score: 250,
                size: 24,
                minWave: 5,
                sniper: true
            },
            BOMBER: {
                className: 'enemy-bomber',
                health: 4,
                speed: 1.2,
                shootRate: 0.0008,
                score: 400,
                size: 28,
                minWave: 6,
                bomber: true
            },
            SHIELD: {
                className: 'enemy-shield',
                health: 8,
                speed: 0.8,
                shootRate: 0.0004,
                score: 500,
                size: 24,
                minWave: 7,
                shield: true
            },
            SPAWNER: {
                className: 'enemy-spawner',
                health: 6,
                speed: 0.5,
                shootRate: 0,
                score: 600,
                size: 36,
                minWave: 8,
                spawner: true
            },
            BERSERKER: {
                className: 'enemy-berserker',
                health: 2,
                speed: 1.5,
                shootRate: 0.001,
                score: 350,
                size: 24,
                minWave: 9,
                berserker: true
            },
            TELEPORTER: {
                className: 'enemy-teleporter',
                health: 3,
                speed: 1,
                shootRate: 0.0006,
                score: 450,
                size: 24,
                minWave: 10,
                teleporter: true
            },
            LASER: {
                className: 'enemy-laser',
                health: 5,
                speed: 0.6,
                shootRate: 0,
                score: 700,
                size: 28,
                minWave: 12,
                laser: true
            },
            STEALTH: {
                className: 'enemy-stealth',
                health: 2,
                speed: 2,
                shootRate: 0.0005,
                score: 400,
                size: 24,
                minWave: 11,
                stealth: true
            },
            ZIGZAG: {
                className: 'enemy-zigzag',
                health: 3,
                speed: 1.8,
                shootRate: 0.0007,
                score: 320,
                size: 24,
                minWave: 6,
                zigzag: true
            },
            HOMING: {
                className: 'enemy-homing',
                health: 2,
                speed: 2,
                shootRate: 0.0008,
                score: 250,
                size: 24,
                minWave: 3,
                homing: true
            }
        };

        // Boss types with different abilities
        const BOSS_TYPES = {
            DESTROYER: {
                color: '#ff0088',
                health: 20,
                abilities: ['multiShot', 'spawnMinions'],
                movePattern: 'horizontal'
            },
            FORTRESS: {
                color: '#8800ff',
                health: 35,
                abilities: ['shield', 'spawnMinions'],
                movePattern: 'stationary'
            },
            MOTHERSHIP: {
                color: '#00ff88',
                health: 50,
                abilities: ['teleport', 'rapidFire', 'spawnMinions'],
                movePattern: 'circular'
            },
            ANNIHILATOR: {
                color: '#ff4400',
                health: 70,
                abilities: ['megaLaser', 'bulletHell', 'ram'],
                movePattern: 'aggressive'
            },
            BOMBER: {
                color: '#ff8800',
                health: 30,
                abilities: ['dropBombs', 'multiShot'],
                movePattern: 'horizontal'
            },
            BURSTER: {
                color: '#ffff00',
                health: 25,
                abilities: ['burstShot', 'spawnMinions'],
                movePattern: 'circular'
            },
            LOCKER: {
                color: '#00ffff',
                health: 40,
                abilities: ['lockOnShot', 'teleport'],
                movePattern: 'aggressive'
            },
            TANK: {
                color: '#aa00aa',
                health: 100,
                abilities: ['shield', 'rapidFire'],
                movePattern: 'stationary'
            },
            SWARMER: {
                color: '#00ff88',
                health: 50,
                abilities: ['spawnMinions', 'bulletHell'],
                movePattern: 'horizontal'
            },
            BEAMER: {
                color: '#ff4444',
                health: 35,
                abilities: ['megaLaser', 'laserBeam'],
                movePattern: 'stationary'
            },
            DIVER: {
                color: '#ff0088',
                health: 45,
                abilities: ['ram', 'burstShot'],
                movePattern: 'aggressive'
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const scoreEl = document.getElementById('score');
        const waveEl = document.getElementById('wave');
        const enemyCountEl = document.getElementById('enemyCount');
        const healthFillEl = document.getElementById('healthFill');
        const livesCountEl = document.getElementById('livesCount');
        const gameOverEl = document.getElementById('gameOver');
        const instructionsEl = document.getElementById('instructions');
        const finalScoreEl = document.getElementById('finalScore');
        const finalWaveEl = document.getElementById('finalWave');
        const activePowerupsEl = document.getElementById('activePowerups');
        const bossHealthBarEl = document.getElementById('bossHealthBar');
        const bossHealthFillEl = document.getElementById('bossHealthFill');
        const highScoreEl = document.getElementById('highScore');
        const topWaveEl = document.getElementById('topWave');
        const tempPowerupTimerEl = document.getElementById('tempPowerupTimer');
        const newRecordEl = document.getElementById('newRecord');
        const pauseMenuEl = document.getElementById('pauseMenu');
        const pauseBtnEl = document.getElementById('pauseBtn');

        let lastTime = 0;

        // Initialize high scores display
        highScoreEl.textContent = highScore;
        topWaveEl.textContent = topWave;

        // Create starfield
        function createStars() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            for (let i = 0; i < 150; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.style.left = Math.random() * width + 'px';
                star.style.top = Math.random() * height + 'px';
                star.style.width = Math.random() * 3 + 1 + 'px';
                star.style.height = star.style.width;
                star.style.animationDelay = Math.random() * 2 + 's';
                canvas.appendChild(star);
            }
        }

        // Create player with visual upgrades
        function createPlayer() {
            const player = document.createElement('div');
            player.className = 'player';
            player.id = 'player';
            player.style.left = gameState.player.x + 'px';
            player.style.top = gameState.player.y + 'px';
            updatePlayerVisuals();
            canvas.appendChild(player);
        }

        function updatePlayerVisuals() {
            const player = document.getElementById('player');
            if (!player) return;

            let shipSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32">';
            
            // Base ship
            shipSvg += '<rect x="14" y="0" width="4" height="8" fill="#00ff00"/>';
            shipSvg += '<rect x="10" y="8" width="12" height="4" fill="#00ff00"/>';
            shipSvg += '<rect x="12" y="12" width="8" height="4" fill="#00ff00"/>';
            shipSvg += '<rect x="8" y="16" width="16" height="4" fill="#00ff00"/>';
            shipSvg += '<rect x="6" y="20" width="20" height="4" fill="#00ff00"/>';
            shipSvg += '<rect x="4" y="24" width="24" height="4" fill="#00ff00"/>';
            shipSvg += '<rect x="12" y="28" width="8" height="4" fill="#00aa00"/>';

            // Wing upgrades for speed
            if (gameState.permanentPowerups.SPEED > 0) {
                shipSvg += '<rect x="0" y="18" width="6" height="8" fill="#00ffff"/>';
                shipSvg += '<rect x="26" y="18" width="6" height="8" fill="#00ffff"/>';
            }

            // Weapon upgrades for power/rapid
            if (gameState.permanentPowerups.POWER > 0 || gameState.permanentPowerups.RAPID > 0) {
                shipSvg += '<rect x="6" y="4" width="4" height="8" fill="#ff4400"/>';
                shipSvg += '<rect x="22" y="4" width="4" height="8" fill="#ff4400"/>';
            }

            // Shield generators
            if (gameState.permanentPowerups.SHIELD > 0) {
                shipSvg += '<rect x="2" y="16" width="4" height="4" fill="#0088ff"/>';
                shipSvg += '<rect x="26" y="16" width="4" height="4" fill="#0088ff"/>';
            }

            // Spread shot indicators
            if (gameState.permanentPowerups.SPREAD > 0) {
                shipSvg += '<rect x="8" y="0" width="2" height="4" fill="#ffff00"/>';
                shipSvg += '<rect x="22" y="0" width="2" height="4" fill="#ffff00"/>';
            }

            // Piercing upgrade glow
            if (gameState.permanentPowerups.PIERCING) {
                shipSvg += '<rect x="13" y="-2" width="6" height="4" fill="#ffffff" opacity="0.8"/>';
            }

            shipSvg += '</svg>';
            player.style.backgroundImage = `url('data:image/svg+xml,${encodeURIComponent(shipSvg)}')`;

            // Temporary powerup effects
            if (gameState.temporaryPowerups.INVINCIBLE) {
                player.style.filter = 'drop-shadow(0 0 10px #ffff44)';
            } else if (gameState.temporaryPowerups.MEGA_RAPID) {
                player.style.filter = 'drop-shadow(0 0 8px #ff4400)';
            } else if (gameState.temporaryPowerups.TRIPLE_DAMAGE) {
                player.style.filter = 'drop-shadow(0 0 8px #ff44ff)';
            } else {
                player.style.filter = 'none';
            }

            // Remove border if has powerup
            const hasPowerup = Object.keys(gameState.permanentPowerups).length > 0;
            player.style.outline = hasPowerup ? 'none' : '1px solid white';
        }

        // Boss functions
        function shouldSpawnBoss() {
            return gameState.wave % 5 === 0 && !gameState.boss && gameState.enemies.length === 0 && gameState.enemiesRemaining === 0;
        }

        function getBossType() {
            const bossLevel = Math.floor((gameState.wave - 1) / 5);
            const types = Object.keys(BOSS_TYPES);
            return types[bossLevel % types.length];
        }

        function spawnBoss() {
            const width = canvas.clientWidth;
            console.log("Spawning boss for wave", gameState.wave);
            showBossWarning();
            
            setTimeout(() => {
                const bossType = getBossType();
                const bossData = BOSS_TYPES[bossType];
                const difficultyMultiplier = getDifficultyMultiplier();
                const healthMultiplier = getHealthMultiplier();
                
                const boss = {
                    x: width / 2 - 40,
                    y: -60,
                    targetY: bossData.movePattern === 'stationary' ? 50 : 100,
                    element: document.createElement('div'),
                    type: bossType,
                    health: Math.round(bossData.health * difficultyMultiplier * healthMultiplier),
                    maxHealth: Math.round(bossData.health * difficultyMultiplier * healthMultiplier),
                    lastShot: Date.now(),
                    lastSpawn: Date.now(),
                    lastAbility: Date.now(),
                    moveDirection: 1,
                    moveTimer: 0,
                    phase: 'entering',
                    abilities: [...bossData.abilities],
                    movePattern: bossData.movePattern,
                    shieldActive: false,
                    shieldTimer: 0
                };
                
                boss.element.className = 'boss';
                boss.element.style.left = boss.x + 'px';
                boss.element.style.top = boss.y + 'px';
                
                // Create boss SVG based on type
                const bossColor = bossData.color;
                const bossSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="80" height="60" viewBox="0 0 80 60">
                    <rect x="30" y="0" width="20" height="8" fill="${bossColor}"/>
                    <rect x="20" y="8" width="40" height="8" fill="${bossColor}"/>
                    <rect x="10" y="16" width="60" height="8" fill="${bossColor}"/>
                    <rect x="0" y="24" width="80" height="12" fill="${bossColor}"/>
                    <rect x="10" y="36" width="60" height="8" fill="${bossColor}"/>
                    <rect x="20" y="44" width="40" height="8" fill="${bossColor}"/>
                    <rect x="30" y="52" width="20" height="8" fill="${bossColor.replace('ff', 'cc')}"/>
                </svg>`;
                
                boss.element.style.backgroundImage = `url('data:image/svg+xml,${encodeURIComponent(bossSvg)}')`;
                canvas.appendChild(boss.element);
                gameState.boss = boss;
                
                bossHealthBarEl.style.display = 'block';
                updateBossHealth();
            }, 3000);
        }

        function showBossWarning() {
            const warning = document.createElement('div');
            warning.className = 'boss-warning';
            warning.innerHTML = `
                <h2 style="margin: 0 0 10px 0;">⚠️ WARNING ⚠️</h2>
                <p style="margin: 0; font-size: 24px;">${getBossType().toUpperCase()} APPROACHING</p>
            `;
            canvas.appendChild(warning);
            
            setTimeout(() => {
                if (warning.parentNode) {
                    warning.remove();
                }
            }, 3000);
        }

        function updateBoss(deltaTime) {
            if (!gameState.boss) return;
            
            const boss = gameState.boss;
            const width = canvas.clientWidth;
            boss.moveTimer += deltaTime;
            const timeMultiplier = gameState.temporaryPowerups.TIME_SLOW ? 0.3 : 1;
            
            if (boss.phase === 'entering') {
                boss.y += 2 * timeMultiplier;
                if (boss.y >= boss.targetY) {
                    boss.phase = 'fighting';
                }
            } else if (boss.phase === 'fighting') {
                // Boss movement patterns
                switch (boss.movePattern) {
                    case 'horizontal':
                        boss.x += Math.sin(boss.moveTimer * 0.001) * 1.5 * timeMultiplier;
                        break;
                    case 'circular':
                        boss.x += Math.sin(boss.moveTimer * 0.002) * 2 * timeMultiplier;
                        boss.y += Math.cos(boss.moveTimer * 0.002) * 0.5 * timeMultiplier;
                        break;
                    case 'aggressive':
                        // Move towards player
                        const dx = gameState.player.x - boss.x;
                        boss.x += Math.sign(dx) * 0.8 * timeMultiplier;
                        if (Math.abs(dx) < 100) {
                            boss.y += 0.5 * timeMultiplier;
                        }
                        break;
                    case 'stationary':
                        // Barely moves
                        boss.x += Math.sin(boss.moveTimer * 0.0005) * 0.5 * timeMultiplier;
                        break;
                }
                
                boss.x = Math.max(40, Math.min(width - 120, boss.x));
                boss.y = Math.max(30, Math.min(200, boss.y));
                
                // Boss abilities
                if (Date.now() - boss.lastAbility > 2000) {
                    const ability = boss.abilities[Math.floor(Math.random() * boss.abilities.length)];
                    executeBossAbility(boss, ability);
                    boss.lastAbility = Date.now();
                }
                
                // Shield mechanics
                if (boss.shieldActive) {
                    boss.shieldTimer -= deltaTime;
                    if (boss.shieldTimer <= 0) {
                        boss.shieldActive = false;
                        boss.element.style.filter = 'none';
                    }
                }
            }
            
            boss.element.style.left = boss.x + 'px';
            boss.element.style.top = boss.y + 'px';

            // Check collision with player
            if (checkCollision(boss, gameState.player, 80, 32) && !gameState.temporaryPowerups.INVINCIBLE && !gameState.player.invulnerable) {
                const damageMultiplier = getDifficultyMultiplier();
                const damage = Math.round(50 * damageMultiplier);
                gameState.player.health -= damage;
                healthFillEl.style.width = Math.max(0, gameState.player.health) + '%';
                if (gameState.player.health <= 0) {
                    playerDeath();
                }
            }
        }

        function executeBossAbility(boss, ability) {
            switch (ability) {
                case 'multiShot':
                    for (let i = -2; i <= 2; i++) {
                        shootBossBullet(boss.x + 40 + i * 15, boss.y + 60);
                    }
                    break;
                    
                case 'spawnMinions':
                    for (let i = 0; i < 2; i++) {
                        const side = i === 0 ? -30 : canvas.clientWidth + 30;
                        spawnBossMinion(side, boss.y + 30);
                    }
                    break;
                    
                case 'laserBeam':
                    createBossLaserBeam(boss.x + 40, boss.y + 60);
                    break;
                    
                case 'shield':
                    boss.shieldActive = true;
                    boss.shieldTimer = 5000;
                    boss.element.style.filter = 'drop-shadow(0 0 15px #00ffff)';
                    break;
                    
                case 'teleport':
                    boss.x = Math.random() * (canvas.clientWidth - 120) + 40;
                    createExplosion(boss.x + 40, boss.y + 30, 30);
                    break;
                    
                case 'rapidFire':
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            if (boss && boss.element.parentNode) {
                                shootBossBullet(boss.x + 40, boss.y + 60);
                            }
                        }, i * 200);
                    }
                    break;
                    
                case 'megaLaser':
                    createBossMegaLaser(boss.x + 40, boss.y + 60);
                    break;
                    
                case 'bulletHell':
                    for (let angle = 0; angle < 360; angle += 30) {
                        const radians = angle * Math.PI / 180;
                        const bulletX = boss.x + 40 + Math.cos(radians) * 30;
                        const bulletY = boss.y + 30 + Math.sin(radians) * 30;
                        shootDirectionalBossBullet(bulletX, bulletY, radians);
                    }
                    break;
                    
                case 'ram':
                    // Boss charges towards player
                    const targetX = gameState.player.x;
                    const chargeSpeed = 5;
                    const chargeInterval = setInterval(() => {
                        if (!boss || !boss.element.parentNode) {
                            clearInterval(chargeInterval);
                            return;
                        }
                        
                        const dx = targetX - boss.x;
                        boss.x += Math.sign(dx) * chargeSpeed;
                        boss.y += 2;
                        
                        if (boss.y > 300 || Math.abs(dx) < 50) {
                            clearInterval(chargeInterval);
                            boss.y = boss.targetY; // Return to original position
                        }
                    }, 50);
                    break;
                case 'dropBombs':
                    for (let i = 0; i < 5; i++) {
                        const bombX = boss.x + Math.random() * 80;
                        const bombY = boss.y + 60;
                        createEnemyBullet(bombX, bombY, Math.PI / 2, 2, 'boss-bullet');
                    }
                    break;
                case 'burstShot':
                    for (let i = -3; i <= 3; i++) {
                        const angle = (Math.PI / 2) + (i * 0.15);
                        shootDirectionalBossBullet(boss.x + 40, boss.y + 60, angle);
                    }
                    break;
                case 'lockOnShot':
                    const dx = gameState.player.x + 16 - (boss.x + 40);
                    const dy = gameState.player.y + 16 - (boss.y + 30);
                    const angle = Math.atan2(dy, dx);
                    shootDirectionalBossBullet(boss.x + 40, boss.y + 60, angle);
                    break;
            }
        }

        function createBossLaserBeam(fromX, fromY) {
            let nearest = gameState.player;
            if (!nearest) return;

            const toX = nearest.x + 16;
            const toY = nearest.y + 16;

            const dx = toX - fromX;
            const dy = toY - fromY;
            const length = Math.sqrt(dx * dx + dy * dy);
            if (length === 0) return;
            const angle = Math.atan2(dy, dx);

            const beam = document.createElement('div');
            beam.className = 'laser-beam';
            beam.style.background = 'linear-gradient(to bottom, #ff0000, #ffaa00)';
            beam.style.boxShadow = '0 0 10px #ff0000';
            beam.style.left = `${fromX}px`;
            beam.style.top = `${fromY}px`;
            beam.style.height = `${length}px`;
            beam.style.transformOrigin = 'top left';
            beam.style.transform = `rotate(${angle}rad)`;
            canvas.appendChild(beam);
            setTimeout(() => beam.remove(), 200);

            // Apply damage if hits player
            const laser = {
                x: fromX,
                y: fromY,
                angle,
                length,
                duration: 200,
                timer: 0,
                isPlayer: false
            };
            gameState.laserBeams.push(laser);
        }

        function createBossMegaLaser(x, y) {
            for (let i = -1; i <= 1; i++) {
                createBossLaserBeam(x + i * 20, y);
            }
        }

        function shootDirectionalBossBullet(x, y, angle) {
            const bullet = {
                x: x,
                y: y,
                element: document.createElement('div'),
                speed: 3,
                angle: angle
            };
            
            bullet.element.className = 'boss-bullet';
            bullet.element.style.left = bullet.x + 'px';
            bullet.element.style.top = bullet.y + 'px';
            canvas.appendChild(bullet.element);
            gameState.enemyBullets.push(bullet);
        }

        function spawnBossMinion(x, y) {
            const availableTypes = Object.keys(ENEMY_TYPES).filter(type => 
                ENEMY_TYPES[type].minWave <= gameState.wave
            );
            const minionType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            spawnEnemyOfType(minionType, x, y);
        }

        function shootBossBullet(x, y) {
            const bullet = {
                x: x,
                y: y,
                element: document.createElement('div'),
                speed: 3
            };
            
            bullet.element.className = 'boss-bullet';
            bullet.element.style.left = bullet.x + 'px';
            bullet.element.style.top = bullet.y + 'px';
            canvas.appendChild(bullet.element);
            gameState.enemyBullets.push(bullet);
        }

        function updateBossHealth() {
            if (!gameState.boss) return;
            const percent = (gameState.boss.health / gameState.boss.maxHealth) * 100;
            bossHealthFillEl.style.width = Math.max(0, percent) + '%';
        }

        function destroyBoss() {
            if (!gameState.boss) return;
            
            createExplosion(gameState.boss.x + 40, gameState.boss.y + 30, 100);
            gameState.boss.element.remove();
            gameState.boss = null;
            bossHealthBarEl.style.display = 'none';
            
            // Boss gives lots of score and guaranteed powerups
            gameState.score += 5000 * (1 + gameState.wave / 10);
            scoreEl.textContent = gameState.score;
            
            // Spawn guaranteed powerups
            const powerupCount = 3 + Math.floor(Math.random() * 2);
            for (let i = 0; i < powerupCount; i++) {
                setTimeout(() => {
                    spawnPowerup(canvas.clientWidth / 2 + (i - Math.floor(powerupCount/2)) * 60, 200);
                }, i * 300);
            }
            
            showBossDefeated();
            
            // Continue to next wave after boss
            setTimeout(() => {
                gameState.waveComplete = true;
                nextWave();
            }, 4000);
        }

        function showBossDefeated() {
            const msg = document.createElement('div');
            msg.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 100, 0, 0.9);
                color: #00ff00;
                padding: 30px 50px;
                border: 3px solid #00ff00;
                border-radius: 15px;
                font-size: 32px;
                text-align: center;
                z-index: 500;
                animation: fadeInOut 4s ease-in-out forwards;
                box-shadow: 0 0 30px #00ff00;
            `;
            msg.innerHTML = `
                <h2 style="margin: 0 0 15px 0; color: #00ffff;">${gameState.boss ? gameState.boss.type.toUpperCase() : 'BOSS'} DEFEATED!</h2>
                <p style="margin: 0; font-size: 20px;">Outstanding pilot!</p>
            `;
            canvas.appendChild(msg);
            
            setTimeout(() => {
                if (msg.parentNode) {
                    msg.remove();
                }
            }, 4000);
        }

        // Enhanced enemy spawning with new types
        function spawnEnemies() {
            if (shouldSpawnBoss()) {
                spawnBoss();
                return;
            }
            
            console.log("Starting enemy spawn for wave", gameState.wave);
            const baseEnemies = Math.min(4 + Math.floor(gameState.wave / 2), 20); // Cap at 20 enemies
            const cols = 5 + Math.floor(gameState.wave / 5);
            const rows = Math.ceil(baseEnemies / cols);
            gameState.enemiesRemaining = 0; // All spawned at once
            gameState.enemySpawnTimer = 0;
            gameState.waveComplete = false;
            enemyCountEl.textContent = rows * cols;
            
            const width = canvas.clientWidth;
            const gridWidth = (cols - 1) * 40;
            const startX = (width - gridWidth) / 2;
            const startY = 50;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    // Get available enemy types for current wave
                    const availableTypes = Object.keys(ENEMY_TYPES).filter(type => 
                        ENEMY_TYPES[type].minWave <= gameState.wave
                    );
                    
                    // Weight selection based on wave progression
                    let enemyType = 'BASIC';
                    const rand = Math.random();
                    
                    if (gameState.wave >= 12) {
                        if (rand < 0.05) enemyType = availableTypes[availableTypes.length - 1]; // Latest enemy
                        else if (rand < 0.15) enemyType = availableTypes[Math.floor(availableTypes.length * 0.8)];
                        else if (rand < 0.35) enemyType = availableTypes[Math.floor(availableTypes.length * 0.6)];
                        else enemyType = availableTypes[Math.floor(Math.random() * Math.min(availableTypes.length, 6))];
                    } else {
                        // Progressive introduction
                        const maxIndex = Math.min(availableTypes.length - 1, Math.floor(gameState.wave / 2));
                        enemyType = availableTypes[Math.floor(Math.random() * (maxIndex + 1))];
                    }
                    
                    const initialX = (c % 2 === 0 ? -50 : width + 50);
                    const initialY = -50 - r * 50;
                    spawnEnemyOfType(enemyType, initialX, initialY, startX + c * 40, startY + r * 40);
                }
            }
        }

        function getDifficultyMultiplier() {
            return 1 + 0.03 * (gameState.wave - 1);
        }

        function getHealthMultiplier() {
            return 1 + 0.5 * Math.floor((gameState.wave - 1) / 5);
        }

        function spawnEnemyOfType(type, x, y, targetX = null, targetY = null) {
            const enemyData = ENEMY_TYPES[type];
            const difficultyMultiplier = getDifficultyMultiplier();
            const healthMultiplier = getHealthMultiplier();
            
            const enemy = {
                type: type,
                x: x,
                y: y,
                element: document.createElement('div'),
                lastShot: Date.now() + Math.random() * 1500,
                lastAction: Date.now(),
                movePattern: Math.floor(Math.random() * 4),
                moveTimer: 0,
                health: Math.round(enemyData.health * difficultyMultiplier * healthMultiplier),
                speed: enemyData.speed * (0.8 + Math.random() * 0.4),
                maxHealth: Math.round(enemyData.health * difficultyMultiplier * healthMultiplier),
                shielded: enemyData.shield && Math.random() < 0.3,
                stealthTimer: enemyData.stealth ? Math.random() * 3000 : 0,
                teleportTimer: enemyData.teleporter ? 5000 + Math.random() * 3000 : 0,
                berserkMode: false,
                spawnedMinions: 0,
                state: targetX !== null ? 'entering' : 'normal',
                targetX: targetX,
                targetY: targetY,
                willDive: Math.random() < 0.5,
                lastDive: Date.now() + Math.random() * 5000 + 3000,
                diveAngle: Math.random() * Math.PI - Math.PI / 2
            };
            
            enemy.element.className = `enemy ${enemyData.className}`;
            enemy.element.style.left = enemy.x + 'px';
            enemy.element.style.top = enemy.y + 'px';
            
            // Special visual effects
            if (enemy.shielded) {
                enemy.element.style.filter = 'drop-shadow(0 0 5px #00ffff)';
            }
            
            canvas.appendChild(enemy.element);
            gameState.enemies.push(enemy);
        }

        function updateEnemyBehavior(enemy, adjustedDelta) {
            const enemyData = ENEMY_TYPES[enemy.type];
            const timeMultiplier = gameState.temporaryPowerups.TIME_SLOW ? 0.3 : 1;
            
            switch(enemy.type) {
                case 'SNIPER':
                    if (enemy.y < 100) {
                        enemy.y += enemy.speed * timeMultiplier;
                    } else {
                        enemy.y = 100;
                        enemy.x += Math.sin(enemy.moveTimer * 0.005) * 3 * timeMultiplier;
                    }
                    break;
                case 'ZIGZAG':
                    enemy.x += Math.sin(enemy.moveTimer * 0.01) * 3 * timeMultiplier;
                    break;
                case 'TELEPORTER':
                    enemy.teleportTimer -= adjustedDelta;
                    if (enemy.teleportTimer <= 0) {
                        enemy.x = Math.random() * (canvas.clientWidth - enemyData.size);
                        createExplosion(enemy.x + enemyData.size / 2, enemy.y + enemyData.size / 2, 20);
                        enemy.teleportTimer = 5000 + Math.random() * 5000;
                    }
                    break;
                case 'BERSERKER':
                    if (!enemy.berserkMode && enemy.health < enemy.maxHealth / 2) {
                        enemy.berserkMode = true;
                        enemy.speed *= 2;
                        enemy.element.style.filter = 'brightness(1.5)';
                    }
                    if (enemy.berserkMode) {
                        const dx = gameState.player.x - enemy.x;
                        enemy.x += Math.sign(dx) * 2 * timeMultiplier;
                    }
                    break;
                case 'STEALTH':
                    enemy.stealthTimer -= adjustedDelta;
                    if (enemy.stealthTimer <= 0) {
                        enemy.element.style.opacity = enemy.element.style.opacity === '0.3' ? '1' : '0.3';
                        enemy.stealthTimer = 2000 + Math.random() * 2000;
                    }
                    break;
                case 'SPAWNER':
                    if (Date.now() - enemy.lastAction > 5000 && enemy.spawnedMinions < 3) {
                        spawnMinion(enemy);
                        enemy.lastAction = Date.now();
                        enemy.spawnedMinions++;
                    }
                    break;
                case 'LASER':
                    if (Date.now() - enemy.lastAction > 8000) {
                        createLaserBeam(enemy.x + enemyData.size / 2, enemy.y + enemyData.size);
                        enemy.lastAction = Date.now();
                    }
                    break;
                case 'HOMING':
                    const dx = gameState.player.x + 16 - (enemy.x + enemyData.size / 2);
                    const dy = gameState.player.y + 16 - (enemy.y + enemyData.size / 2);
                    const angle = Math.atan2(dy, dx);
                    enemy.x += Math.cos(angle) * enemy.speed * timeMultiplier;
                    enemy.y += Math.sin(angle) * enemy.speed * timeMultiplier;
                    break;
            }
        }

        function spawnMinion(enemy) {
            const minionType = 'BASIC';
            const minionX = enemy.x + Math.random() * 20 - 10;
            const minionY = enemy.y + 20;
            spawnEnemyOfType(minionType, minionX, minionY);
        }

        function enemyShoot(enemy) {
            const enemyData = ENEMY_TYPES[enemy.type];
            let bulletSpeed = 4;
            let bulletClass = 'enemy-bullet';
            let angle = undefined;

            if (enemy.type === 'SNIPER') {
                const dx = gameState.player.x + 16 - (enemy.x + enemyData.size / 2);
                const dy = gameState.player.y + 16 - (enemy.y + enemyData.size / 2);
                angle = Math.atan2(dy, dx);
                bulletSpeed = 6;
            } else if (enemy.type === 'BOMBER') {
                for (let i = -1; i <= 1; i++) {
                    createEnemyBullet(enemy.x + enemyData.size / 2 + i * 10, enemy.y + enemyData.size, undefined, bulletSpeed, bulletClass);
                }
                return;
            } else if (enemy.type === 'HEAVY') {
                bulletSpeed = 3;
                bulletClass = 'boss-bullet';
            }

            createEnemyBullet(enemy.x + enemyData.size / 2, enemy.y + enemyData.size, angle, bulletSpeed, bulletClass);
        }

        function createEnemyBullet(x, y, angle, speed, className = 'enemy-bullet') {
            const bullet = {
                x,
                y,
                angle,
                speed,
                element: document.createElement('div')
            };
            bullet.element.className = className;
            bullet.element.style.left = x + 'px';
            bullet.element.style.top = y + 'px';
            canvas.appendChild(bullet.element);
            gameState.enemyBullets.push(bullet);
        }

        function shootForEntity(entity, offsetX) {
            const now = Date.now();
            let fireInterval = 300;
            if (gameState.permanentPowerups.RAPID) {
                fireInterval -= gameState.permanentPowerups.RAPID * 50;
            }
            if (gameState.temporaryPowerups.MEGA_RAPID) {
                fireInterval = 50;
            }

            if (now - entity.lastShoot < fireInterval) return;
            entity.lastShoot = now;

            let damage = 1 + (gameState.permanentPowerups.POWER || 0);
            if (gameState.temporaryPowerups.TRIPLE_DAMAGE) {
                damage *= 3;
            }

            let spreadCount = 1 + 2 * (gameState.permanentPowerups.SPREAD || 0);
            if (gameState.temporaryPowerups.SUPER_SPREAD) {
                spreadCount = 11;
            }

            const spreadAngle = 0.1;
            for (let i = 0; i < spreadCount; i++) {
                const offset = (i - (spreadCount - 1) / 2) * spreadAngle;
                createPlayerBullet(entity.x + offsetX, entity.y, damage, offset);
            }
        }

        function createPlayerBullet(x, y, damage, angle = 0) {
            const bullet = {
                x,
                y,
                speed: 10,
                damage,
                angle,
                element: document.createElement('div')
            };
            bullet.element.className = 'bullet';
            bullet.element.style.left = x + 'px';
            bullet.element.style.top = y + 'px';
            canvas.appendChild(bullet.element);
            gameState.bullets.push(bullet);
        }

        function createLaserBeam(x, y) {
            const height = canvas.clientHeight;
            const laser = {
                x: x - 2,
                y: y,
                element: document.createElement('div'),
                duration: 3000,
                timer: 0,
                isPlayer: false
            };
            
            laser.element.className = 'laser-beam';
            laser.element.style.left = laser.x + 'px';
            laser.element.style.top = laser.y + 'px';
            laser.element.style.height = (height - y) + 'px';
            canvas.appendChild(laser.element);
            gameState.laserBeams.push(laser);
        }

        function createPlayerLaser(x) {
            const laser = {
                x: x - 2,
                y: 0,
                height: gameState.player.y,
                element: document.createElement('div'),
                duration: 200,
                timer: 0,
                isPlayer: true
            };
            laser.element.className = 'laser-beam';
            laser.element.style.background = 'linear-gradient(to top, #00ffff, #00aaff)';
            laser.element.style.left = laser.x + 'px';
            laser.element.style.top = '0px';
            laser.element.style.height = laser.height + 'px';
            canvas.appendChild(laser.element);
            gameState.laserBeams.push(laser);
        }

        function spawnPowerup(x, y) {
            if (Math.random() < 0.8) return;

            const isPermanent = Math.random() < 0.5;
            const types = Object.keys(POWERUPS).filter(t => POWERUPS[t].permanent === isPermanent && t !== 'LIFE');
            let type = types[Math.floor(Math.random() * types.length)];
            if (Math.random() < 0.02 && isPermanent) type = 'LIFE';

            const powerupData = POWERUPS[type];
            const powerup = {
                x: x - 10,
                y,
                type,
                element: document.createElement('div')
            };
            powerup.element.className = `powerup powerup-${isPermanent ? 'permanent' : 'temporary'}`;
            powerup.element.style.left = powerup.x + 'px';
            powerup.element.style.top = powerup.y + 'px';
            powerup.element.style.borderColor = isPermanent ? '#00ff00' : '#aa44ff';
            powerup.element.style.boxShadow = `0 0 10px ${isPermanent ? '#00ff00' : '#aa44ff'}`;
            powerup.element.textContent = powerupData.symbol;
            powerup.element.style.color = powerupData.color;
            canvas.appendChild(powerup.element);
            gameState.powerups.push(powerup);
        }

        function activatePowerup(type) {
            const data = POWERUPS[type];
            if (data.instant) {
                if (type === 'LIFE') {
                    gameState.player.lives++;
                } else if (type === 'HEALTH_PACK') {
                    gameState.player.health = Math.min(100, gameState.player.health + 50);
                    healthFillEl.style.width = gameState.player.health + '%';
                } else if (type === 'NUKES') {
                    // Damage all enemies and boss heavily
                    gameState.enemies.forEach(enemy => {
                        enemy.health -= 999;
                    });
                    if (gameState.boss) {
                        gameState.boss.health -= gameState.boss.maxHealth / 2;
                        updateBossHealth();
                        if (gameState.boss.health <= 0) {
                            destroyBoss();
                        }
                    }
                }
                livesCountEl.textContent = gameState.player.lives;
                return;
            }
            if (data.permanent) {
                gameState.permanentPowerups[type] = (gameState.permanentPowerups[type] || 0) + 1;
                updatePowerupDisplay();
                updatePlayerVisuals();
                gameState.companions.forEach(comp => {
                    comp.element.style.outline = 'none';
                });
                if (type === 'COMPANION') {
                    createCompanion();
                }
            } else {
                gameState.temporaryPowerups[type] = Date.now() + data.duration;
                updatePlayerVisuals();
            }

            const msg = document.createElement('div');
            msg.textContent = data.name + ' Activated!';
            msg.style.position = 'absolute';
            msg.style.left = gameState.player.x + 'px';
            msg.style.top = (gameState.player.y - 20) + 'px';
            msg.style.color = data.color;
            msg.style.animation = 'fadeUp 2s ease-out forwards';
            canvas.appendChild(msg);
            setTimeout(() => msg.remove(), 2000);
        }

        function createCompanion() {
            const comp = {
                x: gameState.player.x - 40,
                y: gameState.player.y,
                health: 1,
                lastShoot: Date.now(),
                element: document.createElement('div')
            };
            comp.element.className = 'player companion';
            let compSvg = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">';
            compSvg += '<rect x="10" y="0" width="4" height="6" fill="#8800ff"/>';
            compSvg += '<rect x="8" y="6" width="8" height="3" fill="#8800ff"/>';
            compSvg += '<rect x="6" y="9" width="12" height="3" fill="#8800ff"/>';
            compSvg += '<rect x="4" y="12" width="16" height="3" fill="#8800ff"/>';
            compSvg += '<rect x="3" y="15" width="18" height="3" fill="#8800ff"/>';
            compSvg += '<rect x="9" y="18" width="6" height="3" fill="#6600cc"/>';
            compSvg += '<rect x="8" y="21" width="8" height="3" fill="#6600cc"/>';
            compSvg += '</svg>';
            comp.element.style.backgroundImage = `url('data:image/svg+xml,${encodeURIComponent(compSvg)}')`;
            comp.element.style.left = comp.x + 'px';
            comp.element.style.top = comp.y + 'px';
            const hasPowerup = Object.keys(gameState.permanentPowerups).length > 0;
            comp.element.style.outline = hasPowerup ? 'none' : '1px solid white';
            canvas.appendChild(comp.element);
            gameState.companions.push(comp);
        }

        function updateTemporaryPowerups() {
            const now = Date.now();
            let timers = [];
            for (let type in gameState.temporaryPowerups) {
                if (now > gameState.temporaryPowerups[type]) {
                    delete gameState.temporaryPowerups[type];
                    updatePlayerVisuals();
                } else {
                    const remaining = Math.ceil((gameState.temporaryPowerups[type] - now) / 1000);
                    timers.push(`${POWERUPS[type].symbol}: ${remaining}s`);
                }
            }
            tempPowerupTimerEl.textContent = timers.join(' | ');
        }

        function updatePowerupDisplay() {
            activePowerupsEl.innerHTML = Object.entries(gameState.permanentPowerups).map(([type, level]) => 
                `${POWERUPS[type].name} Lv${level}`
            ).join('<br>');
        }

        function playerDeath() {
            createExplosion(gameState.player.x + 16, gameState.player.y + 16, 60);
            gameState.player.lives--;
            livesCountEl.textContent = gameState.player.lives;
            if (gameState.player.lives <= 0) {
                endGame();
                return;
            }
            gameState.player.health = 100;
            healthFillEl.style.width = '100%';
            gameState.player.invulnerable = Date.now() + 3000;
            gameState.temporaryPowerups = {};
            gameState.companions.forEach(comp => comp.element.remove());
            gameState.companions = [];
        }

        function checkCollision(obj1, obj2, size1, size2) {
            return (
                obj1.x < obj2.x + size2 &&
                obj1.x + size1 > obj2.x &&
                obj1.y < obj2.y + size2 &&
                obj1.y + size1 > obj2.y
            );
        }

        function createExplosion(x, y, size = 50) {
            const explosion = {
                x: x - size / 2,
                y: y - size / 2,
                timer: 500,
                element: document.createElement('div')
            };
            explosion.element.className = 'explosion';
            explosion.element.style.left = explosion.x + 'px';
            explosion.element.style.top = explosion.y + 'px';
            explosion.element.style.width = size + 'px';
            explosion.element.style.height = size + 'px';
            canvas.appendChild(explosion.element);
            gameState.explosions.push(explosion);
        }

        // Update game
        function updateGame(deltaTime) {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            if (!gameState.playing) return;
            if (gameState.paused) return;

            const playerEl = document.getElementById('player');
            
            // Update temporary powerups
            updateTemporaryPowerups();
            
            // Time slow effect
            const timeMultiplier = gameState.temporaryPowerups.TIME_SLOW ? 0.3 : 1;
            const adjustedDelta = deltaTime * timeMultiplier;
            
            // Player movement with speed upgrades
            const baseSpeed = gameState.player.speed;
            const permanentSpeed = gameState.permanentPowerups.SPEED || 0;
            const moveSpeed = baseSpeed + permanentSpeed;
            
            if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) {
                gameState.player.x -= moveSpeed;
            }
            if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) {
                gameState.player.x += moveSpeed;
            }
            
            gameState.player.x = Math.max(0, Math.min(width - 32, gameState.player.x));
            playerEl.style.left = gameState.player.x + 'px';
            
            // Show invulnerability or invincible effect
            const isInvulnerable = (gameState.player.invulnerable && Date.now() < gameState.player.invulnerable);
            const isInvincible = gameState.temporaryPowerups.INVINCIBLE;
            
            if (isInvulnerable || isInvincible) {
                if (isInvincible) {
                    playerEl.style.opacity = '1';
                } else {
                    playerEl.style.opacity = Math.sin(Date.now() / 100) > 0 ? '0.3' : '1';
                }
            } else {
                playerEl.style.opacity = '1';
                gameState.player.invulnerable = null;
            }

            // Auto-shoot if holding space
            const now = Date.now();
            let fireInterval = 300;
            if (gameState.permanentPowerups.RAPID) {
                fireInterval -= gameState.permanentPowerups.RAPID * 50;
            }
            if (gameState.temporaryPowerups.MEGA_RAPID) {
                fireInterval = 50;
            }
            if (gameState.keys['Space'] && now - gameState.lastShoot >= fireInterval) {
                gameState.lastShoot = now;
                shootForEntity(gameState.player, 16);
            }

            // Companions shoot independently
            gameState.companions.forEach(comp => {
                if (now - comp.lastShoot >= fireInterval) {
                    comp.lastShoot = now;
                    shootForEntity(comp, 12);
                }
            });

            // Health regeneration from shield powerup
            const shieldRegen = gameState.permanentPowerups.SHIELD || 0;
            if (shieldRegen > 0 && gameState.player.health < 100) {
                gameState.player.health = Math.min(100, gameState.player.health + shieldRegen * deltaTime / 1000);
                healthFillEl.style.width = gameState.player.health + '%';
            }

            // Update boss
            updateBoss(adjustedDelta);

            // No spawn timer since formation spawn

            // Update bullets
            gameState.bullets = gameState.bullets.filter(bullet => {
                bullet.y -= bullet.speed;
                bullet.x += Math.sin(bullet.angle) * bullet.speed;
                bullet.element.style.top = bullet.y + 'px';
                bullet.element.style.left = bullet.x + 'px';
                
                if (bullet.y < -20 || bullet.x < -20 || bullet.x > width + 20) {
                    bullet.element.remove();
                    return false;
                }
                
                // Check boss collision
                if (gameState.boss && checkCollision(bullet, gameState.boss, 6, 80)) {
                    let damage = bullet.damage;
                    if (gameState.boss.shieldActive) {
                        damage = Math.max(1, Math.floor(damage / 3));
                    }
                    
                    gameState.boss.health -= damage;
                    updateBossHealth();
                    
                    if (gameState.boss.health <= 0) {
                        destroyBoss();
                    }
                    
                    if (!gameState.permanentPowerups.PIERCING) {
                        bullet.element.remove();
                        return false;
                    }
                }
                
                // Check enemy collisions
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    const enemyData = ENEMY_TYPES[enemy.type];
                    
                    if (checkCollision(bullet, enemy, 6, enemyData.size)) {
                        let damage = bullet.damage;
                        if (enemy.shielded) {
                            damage = Math.max(1, Math.floor(damage / 2));
                            if (Math.random() < 0.3) {
                                enemy.shielded = false;
                                enemy.element.style.filter = 'none';
                            }
                        }
                        
                        enemy.health -= damage;
                        
                        if (enemy.health <= 0) {
                            createExplosion(enemy.x + enemyData.size/2, enemy.y + enemyData.size/2);
                            spawnPowerup(enemy.x + enemyData.size/2, enemy.y + enemyData.size/2);
                            enemy.element.remove();
                            gameState.enemies.splice(i, 1);
                            let scoreGain = enemyData.score * (1 + gameState.wave / 10);
                            if (gameState.temporaryPowerups.DOUBLE_SCORE) {
                                scoreGain *= 2;
                            }
                            gameState.score += scoreGain;
                            scoreEl.textContent = Math.floor(gameState.score);
                        }
                        
                        if (!gameState.permanentPowerups.PIERCING) {
                            bullet.element.remove();
                            return false;
                        }
                    }
                }
                
                return true;
            });

            // Update enemy bullets
            gameState.enemyBullets = gameState.enemyBullets.filter(bullet => {
                const speed = (bullet.speed || 4) * timeMultiplier;
                
                if (bullet.angle !== undefined) {
                    bullet.x += Math.cos(bullet.angle) * speed;
                    bullet.y += Math.sin(bullet.angle) * speed;
                } else {
                    bullet.y += speed;
                }
                
                bullet.element.style.top = bullet.y + 'px';
                bullet.element.style.left = bullet.x + 'px';
                
                if (bullet.y > height + 20 || bullet.x < -20 || bullet.x > width + 20) {
                    bullet.element.remove();
                    return false;
                }
                
                // Check player collision (with invulnerability/invincible)
                if (checkCollision(bullet, gameState.player, 6, 32) && !isInvulnerable && !isInvincible) {
                    createExplosion(gameState.player.x + 16, gameState.player.y + 16);
                    bullet.element.remove();
                    const damageMultiplier = getDifficultyMultiplier();
                    const damage = Math.round(15 * damageMultiplier);
                    gameState.player.health -= damage;
                    healthFillEl.style.width = Math.max(0, gameState.player.health) + '%';
                    
                    if (gameState.player.health <= 0) {
                        playerDeath();
                    }
                    return false;
                }

                // Check companion collisions
                for (let i = gameState.companions.length - 1; i >= 0; i--) {
                    const comp = gameState.companions[i];
                    if (checkCollision(bullet, comp, 6, 24)) {
                        const damageMultiplier = getDifficultyMultiplier();
                        const damage = Math.round(15 * damageMultiplier);
                        comp.health -= damage;
                        bullet.element.remove();
                        if (comp.health <= 0) {
                            createExplosion(comp.x + 12, comp.y + 12, 40);
                            comp.element.remove();
                            gameState.companions.splice(i, 1);
                        }
                        return false;
                    }
                }
                
                return true;
            });

            // Update laser beams
            gameState.laserBeams = gameState.laserBeams.filter(laser => {
                laser.timer += deltaTime;
                
                if (laser.timer > laser.duration) {
                    laser.element.remove();
                    return false;
                }
                
                if (laser.isPlayer) {
                    // Check enemy collisions
                    for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                        const enemy = gameState.enemies[i];
                        const enemyData = ENEMY_TYPES[enemy.type];
                        if (checkCollision(laser, enemy, 4, enemyData.size)) {
                            enemy.health -= 5;
                            if (enemy.health <= 0) {
                                createExplosion(enemy.x + enemyData.size / 2, enemy.y + enemyData.size / 2);
                                spawnPowerup(enemy.x + enemyData.size / 2, enemy.y + enemyData.size / 2);
                                enemy.element.remove();
                                gameState.enemies.splice(i, 1);
                                let scoreGain = enemyData.score * (1 + gameState.wave / 10);
                                if (gameState.temporaryPowerups.DOUBLE_SCORE) {
                                    scoreGain *= 2;
                                }
                                gameState.score += scoreGain;
                                scoreEl.textContent = Math.floor(gameState.score);
                            }
                        }
                    }
                    // Check boss
                    if (gameState.boss && checkCollision(laser, gameState.boss, 4, 80)) {
                        gameState.boss.health -= 5;
                        updateBossHealth();
                        if (gameState.boss.health <= 0) {
                            destroyBoss();
                        }
                    }
                } else {
                    // Check player collision with laser
                    if (checkCollision(laser, gameState.player, 4, 32) && !isInvulnerable && !isInvincible) {
                        if (Date.now() - (laser.lastHit || 0) > 500) { // Damage every 0.5 seconds
                            const damageMultiplier = getDifficultyMultiplier();
                            const damage = Math.round(20 * damageMultiplier);
                            gameState.player.health -= damage;
                            healthFillEl.style.width = Math.max(0, gameState.player.health) + '%';
                            laser.lastHit = Date.now();
                            
                            if (gameState.player.health <= 0) {
                                playerDeath();
                            }
                        }
                    }

                    // Check companion collision with laser
                    for (let i = gameState.companions.length - 1; i >= 0; i--) {
                        const comp = gameState.companions[i];
                        if (checkCollision(laser, comp, 4, 24)) {
                            if (Date.now() - (laser.lastCompHit || 0) > 500) {
                                const damageMultiplier = getDifficultyMultiplier();
                                const damage = Math.round(20 * damageMultiplier);
                                comp.health -= damage;
                                laser.lastCompHit = Date.now();
                                if (comp.health <= 0) {
                                    createExplosion(comp.x + 12, comp.y + 12, 40);
                                    comp.element.remove();
                                    gameState.companions.splice(i, 1);
                                }
                            }
                        }
                    }
                }
                
                return true;
            });

            // Update enemies
            gameState.enemies = gameState.enemies.filter((enemy, index) => {
                const enemyData = ENEMY_TYPES[enemy.type];
                enemy.moveTimer += adjustedDelta;
                
                // Update special enemy behaviors
                updateEnemyBehavior(enemy, adjustedDelta);
                
                // Basic movement
                if (enemy.type !== 'SNIPER') {
                    if (enemy.state === 'entering') {
                        const dx = enemy.targetX - enemy.x;
                        const dy = enemy.targetY - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 5) {
                            enemy.state = 'formed';
                        } else {
                            const moveSpeed = enemy.speed * 2 * timeMultiplier; // Faster entry
                            enemy.x += (dx / dist) * moveSpeed;
                            enemy.y += (dy / dist) * moveSpeed;
                        }
                    } else if (enemy.state === 'formed') {
                        enemy.x = enemy.targetX + Math.sin(enemy.moveTimer * 0.002) * 10;
                        enemy.y = enemy.targetY;
                        if (enemy.willDive && Date.now() > enemy.lastDive) {
                            enemy.state = 'diving';
                        }
                    } else if (enemy.state === 'diving') {
                        enemy.y += enemy.speed * 1.5 * timeMultiplier;
                        enemy.x += Math.sin(enemy.moveTimer * 0.01) * 5 * timeMultiplier; // Curve during dive
                        enemy.shootRate *= 2; // Shoot more during dive
                    } else {
                        enemy.y += enemy.speed * timeMultiplier;
                    }
                }
                
                // Special movement patterns
                if (enemy.type === 'KAMIKAZE' && enemy.y > height / 2) {
                    const dx = gameState.player.x - enemy.x;
                    enemy.x += Math.sign(dx) * 3 * timeMultiplier;
                } else if (enemy.type !== 'ZIGZAG' && enemy.type !== 'SNIPER' && enemy.state !== 'entering' && enemy.state !== 'diving') {
                    // Enhanced movement patterns for non-zigzag enemies
                    const intensity = 1 + (gameState.wave - 1) * 0.2;
                    switch (enemy.movePattern) {
                        case 0:
                            enemy.x += (Math.random() - 0.5) * 0.5 * intensity * timeMultiplier;
                            break;
                        case 1:
                            enemy.x += Math.sin(enemy.moveTimer * 0.005) * 2 * intensity * timeMultiplier;
                            break;
                        case 2:
                            enemy.x += Math.sin(enemy.moveTimer * 0.002) * 1.5 * intensity * timeMultiplier;
                            break;
                        case 3:
                            enemy.x += Math.sin(enemy.moveTimer * 0.008) * 3 * intensity * timeMultiplier;
                            break;
                    }
                }
                
                enemy.x = Math.max(0, Math.min(width - enemyData.size, enemy.x));
                
                // Check collision with player (kamikaze and berserker)
                if ((enemy.type === 'KAMIKAZE' || enemy.berserkMode) && checkCollision(enemy, gameState.player, enemyData.size, 32)) {
                    if (!isInvulnerable && !isInvincible) {
                        const damageMultiplier = getDifficultyMultiplier();
                        const damage = Math.round((enemy.type === 'KAMIKAZE' ? 25 : 20) * damageMultiplier);
                        createExplosion(enemy.x + enemyData.size/2, enemy.y + enemyData.size/2, 70);
                        gameState.player.health -= damage;
                        healthFillEl.style.width = Math.max(0, gameState.player.health) + '%';
                        
                        if (gameState.player.health <= 0) {
                            playerDeath();
                        }
                    }
                    
                    enemy.element.remove();
                    let scoreGain = enemyData.score;
                    if (gameState.temporaryPowerups.DOUBLE_SCORE) {
                        scoreGain *= 2;
                    }
                    gameState.score += scoreGain;
                    scoreEl.textContent = Math.floor(gameState.score);
                    return false;
                }
                
                // Remove enemies that go off screen
                if (enemy.y > height + 50) {
                    enemy.element.remove();
                    return false;
                }
                
                enemy.element.style.left = enemy.x + 'px';
                enemy.element.style.top = enemy.y + 'px';
                
                // Enemy shooting with time slow consideration
                if (Math.random() < enemyData.shootRate * adjustedDelta) {
                    enemyShoot(enemy);
                }

                return true;
            });

            // Update companions
            gameState.companions.forEach((comp, index) => {
                let side = index % 2 === 0 ? -1 : 1;
                let offset = 40 + 40 * Math.floor(index / 2);
                const targetX = gameState.player.x + side * offset;
                const targetY = gameState.player.y;
                comp.x += (targetX - comp.x) * 0.1;
                comp.y += (targetY - comp.y) * 0.1;
                comp.element.style.left = comp.x + 'px';
                comp.element.style.top = comp.y + 'px';
            });

            // Update powerups
            gameState.powerups = gameState.powerups.filter(powerup => {
                powerup.y += 3 * timeMultiplier;
                powerup.element.style.top = powerup.y + 'px';
                
                if (powerup.y > height + 50) {
                    powerup.element.remove();
                    return false;
                }
                
                if (checkCollision(powerup, gameState.player, 20, 32)) {
                    activatePowerup(powerup.type);
                    powerup.element.remove();
                    return false;
                }
                
                return true;
            });

            // Update explosions
            gameState.explosions = gameState.explosions.filter(explosion => {
                explosion.timer -= deltaTime;
                if (explosion.timer <= 0) {
                    explosion.element.remove();
                    return false;
                }
                return true;
            });

            enemyCountEl.textContent = gameState.enemies.length;

            // Check wave completion
            const waveComplete = gameState.enemies.length === 0 && 
                                !gameState.boss && 
                                !gameState.waveComplete;
            
            if (waveComplete) {
                gameState.waveComplete = true;
                showWaveComplete();
                setTimeout(() => nextWave(), 3000);
            }
        }

        // Wave progression
        function nextWave() {
            gameState.wave++;
            gameState.player.health = Math.min(100, gameState.player.health + 15);
            waveEl.textContent = gameState.wave;
            healthFillEl.style.width = gameState.player.health + '%';
            
            // Update high scores
            if (gameState.wave > topWave) {
                topWave = gameState.wave;
                localStorage.setItem('spaceGalacticaTopWave', topWave);
                topWaveEl.textContent = topWave;
            }
            
            setTimeout(() => {
                spawnEnemies();
            }, 1000);
        }

        function showWaveComplete() {
            const waveMsg = document.createElement('div');
            waveMsg.style.cssText = `
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 50, 0, 0.9);
                color: #00ff00;
                padding: 30px 50px;
                border: 3px solid #00ff00;
                border-radius: 15px;
                font-size: 28px;
                text-align: center;
                z-index: 500;
                animation: fadeInOut 3s ease-in-out forwards;
                box-shadow: 0 0 20px #00ff00;
            `;
            waveMsg.innerHTML = `
                <h2 style="margin: 0 0 10px 0; color: #00ffff;">WAVE ${gameState.wave} CLEARED!</h2>
                <p style="margin: 0; font-size: 18px;">Preparing next assault wave...</p>
            `;
            canvas.appendChild(waveMsg);
            
            setTimeout(() => {
                if (waveMsg.parentNode) {
                    waveMsg.remove();
                }
            }, 3000);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.code] = true;
            
            if (e.code === 'Space' && gameState.playing) {
                e.preventDefault();
            }

            if (e.code === 'Escape' && gameState.playing) {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            gameState.keys[e.code] = false;
        });

        canvas.addEventListener('click', (e) => {
            if (gameState.playing) {
                const now = Date.now();
                let fireInterval = 300;
                if (gameState.permanentPowerups.RAPID) {
                    fireInterval -= gameState.permanentPowerups.RAPID * 50;
                }
                if (gameState.temporaryPowerups.MEGA_RAPID) {
                    fireInterval = 50;
                }
                if (now - gameState.lastShoot >= fireInterval) {
                    gameState.lastShoot = now;
                    shootForEntity(gameState.player, 16);
                }
            }
        });

        pauseBtnEl.addEventListener('click', togglePause);

        function togglePause() {
            if (!gameState.playing) return;
            gameState.paused = !gameState.paused;
            if (gameState.paused) {
                pauseMenuEl.style.display = 'block';
            } else {
                pauseMenuEl.style.display = 'none';
                lastTime = performance.now();
            }
        }

        function resumeGame() {
            gameState.paused = false;
            pauseMenuEl.style.display = 'none';
            lastTime = performance.now();
        }

        // Game functions
        function startGame() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            instructionsEl.style.display = 'none';
            gameState.playing = true;
            gameState.player.x = width / 2 - 16;
            gameState.player.y = height - 100;
            gameState.player.health = 100;
            gameState.player.lives = 3;
            gameState.score = 0;
            gameState.wave = 1;
            gameState.waveComplete = false;
            gameState.boss = null;
            
            scoreEl.textContent = gameState.score;
            waveEl.textContent = '1';
            livesCountEl.textContent = gameState.player.lives;
            healthFillEl.style.width = '100%';
            bossHealthBarEl.style.display = 'none';
            tempPowerupTimerEl.textContent = '';
            updatePowerupDisplay();
            
            createPlayer();
            
            setTimeout(() => {
                spawnEnemies();
            }, 500);
            
            gameLoop();
        }

        function endGame() {
            gameState.playing = false;
            finalScoreEl.textContent = Math.floor(gameState.score);
            finalWaveEl.textContent = gameState.wave;
            
            // Check for new records
            let newRecord = false;
            if (gameState.score > highScore) {
                highScore = Math.floor(gameState.score);
                localStorage.setItem('spaceGalacticaHighScore', highScore);
                highScoreEl.textContent = highScore;
                newRecord = true;
            }
            
            if (gameState.wave > topWave) {
                topWave = gameState.wave;
                localStorage.setItem('spaceGalacticaTopWave', topWave);
                topWaveEl.textContent = topWave;
                newRecord = true;
            }
            
            if (newRecord) {
                newRecordEl.style.display = 'block';
            } else {
                newRecordEl.style.display = 'none';
            }
            
            gameOverEl.style.display = 'block';
        }

        function restartGame() {
            // Clear all game objects
            gameState.bullets.forEach(bullet => bullet.element.remove());
            gameState.enemies.forEach(enemy => enemy.element.remove());
            gameState.enemyBullets.forEach(bullet => bullet.element.remove());
            gameState.explosions.forEach(explosion => explosion.element.remove());
            gameState.powerups.forEach(powerup => powerup.element.remove());
            gameState.laserBeams.forEach(laser => laser.element.remove());
            gameState.companions.forEach(comp => comp.element.remove());
            
            if (gameState.boss) {
                gameState.boss.element.remove();
            }
            
            const playerEl = document.getElementById('player');
            if (playerEl) playerEl.remove();
            
            // Reset game state but keep permanent powerups
            gameState = {
                playing: false,
                paused: false,
                player: { 
                    x: 0, 
                    y: 0, 
                    health: 100, 
                    speed: 6,
                    lives: 3
                },
                bullets: [],
                enemies: [],
                enemyBullets: [],
                explosions: [],
                powerups: [],
                permanentPowerups: {},
                temporaryPowerups: {},
                tempPowerupTimer: {},
                score: 0,
                wave: 1,
                enemiesRemaining: 0,
                enemySpawnTimer: 0,
                keys: {},
                waveComplete: false,
                lastShoot: 0,
                boss: null,
                bossSpawnTimer: 0,
                laserBeams: [],
                companions: []
            };
            
            gameOverEl.style.display = 'none';
            instructionsEl.style.display = 'block';
            bossHealthBarEl.style.display = 'none';
            activePowerupsEl.innerHTML = '';
            tempPowerupTimerEl.textContent = '';
            pauseMenuEl.style.display = 'none';
        }

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            updateGame(deltaTime);
            if (gameState.playing) {
                requestAnimationFrame(gameLoop);
            }
        }

        // Initialize game
        createStars();
    </script>
</body>
</html>